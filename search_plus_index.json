{"./":{"url":"./","title":"前言","keywords":"","body":"本书内容 Markdown 公式指导手册 PlantUML语法指导手册 Mermaid 图表指导手册 1号表题 2号标题 3号标题 4号标题 5号标题 6号标题 #include using namespace std; class Singleton { public: static Singleton& Instance() { static Singleton instance; return instance; } private: Singleton() {} Singleton(const Singleton &another) {} }; int main() { Singleton &singleton1 = Singleton::Instance(); Singleton &singleton2 = Singleton::Instance(); cout var className='atoc';"},"1-Chapter/0-README.html":{"url":"1-Chapter/0-README.html","title":"第一章 Markdown公式指导手册","keywords":"","body":"Markdown 公式指导手册 本文为 katex 在 gitbook环境下的语法指引，katex负责公式显示支持。例如：\\sum_{i=0}^n a_i=0，访问Katex以参考更多使用方法,Katex并不支持所有的LaTeX语法。如果遇到不支持的语法，可以访问 MathJax 以参考更多使用方法。 本章参考: Cmd Markdown 简明语法手册 Cmd Markdown 公式指导手册 Katex 在线编辑器 var className='atoc';"},"1-Chapter/1-公式使用参考.html":{"url":"1-Chapter/1-公式使用参考.html","title":"第一章 第1节：公式使用参考","keywords":"","body":"第一章 第1节：公式使用参考 如何插入公式 LaTeX的数学公式有两种：行内公式和独立公式。行内公式放在文中与其它文字混编，独立公式单独成行。 行内公式示例 这是行内公式: {% math %}E=mc^2{% endmath %} 看看在行内吗? 这是行内公式: {% math %}E=mc^2{% endmath %} 看看在行内吗? 行内公式示例:{% math %}J_\\alpha(x) = {\\sum_{m=0}^{\\infty} {\\frac{(-1)^m}{m!\\Gamma(m+\\alpha+1)}}} {\\left({\\frac{x}{2}}\\right)}^{2m+\\alpha} {\\text{, 显示行内公式}}{% endmath %} 这是行内公式: E=mc^2 看看在行内吗?这是行内公式: E=mc^2 看看在行内吗? 行内公式示例:J_\\alpha(x) = {\\sum_{m=0}^{\\infty} {\\frac{(-1)^m}{m!\\Gamma(m+\\alpha+1)}}} {\\left({\\frac{x}{2}}\\right)}^{2m+\\alpha} {\\text{, 显示行内公式}} 独立公式示例 {% math %} E=mc^2 {% endmath %} {% math %} J_\\alpha(x) = {\\sum_{m=0}^{\\infty}} {\\frac{(-1)^m}{m!\\Gamma(m+\\alpha+1)}} {\\left({\\frac{x}{2}}\\right)}^{2m+\\alpha} {\\text{, 显示独立公式}} {% endmath %} E=mc^2 J_\\alpha(x) = {\\sum_{m=0}^{\\infty}} {\\frac{(-1)^m}{m!\\Gamma(m+\\alpha+1)}} {\\left({\\frac{x}{2}}\\right)}^{2m+\\alpha} {\\text{, 显示独立公式}} 注意: 大括号及其包含的内容可以用两个$代替 。 katex不支持单个$符号包着行内公式。 katex公式text内容需要使用半角逗号。 katex好像暂时不支持公式自动编号 如何输入上下标 ^ 表示上标, _ 表示下标。如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 上下标示例公式 {% math %} {x^y}^z = (1+e^x)^{-2xy^w} {% endmath %} {x^y}^z = (1+e^x)^{-2xy^w} {% math %} {^1_2}\\bigotimes{^3_4} {% endmath %} {^1_2}\\bigotimes{^3_4} 注意: Katex0.7.1和Katex 0.11.1使用\\rm不能套２层括号 Katex不支持\\sideset 如何输入括号和分隔符 ()、[] 和 | 表示符号本身，使用 \\{\\} 来表示 {} 。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。 一些特殊的括号： 输入 显示 输入 显示 \\langle \\langle \\rangle \\rangle \\lceil \\lceil \\rceil \\rceil \\lfloor \\lfloor \\rfloor \\rfloor \\lbrace \\lbrace \\lbrace \\lbrace 括号使用示例: {% math %} f(x,y,z) = 3y^2z {\\left( 3+ \\frac{7x+5}{1+y^2} \\right)} {% endmath %} f(x,y,z) = 3y^2z {\\left( 3+ \\frac{7x+5}{1+y^2} \\right)} 扩大|使用示例 {% math %} \\left. {\\rm d}u \\over {\\rm d}x \\right|_{x=0} {% endmath %} \\left. {\\rm d}u \\over {\\rm d}x \\right|_{x=0} 注意: \\left和\\right可以扩大()、[]和| 大括号{}有特殊用途所以需要转义 如何输入分数 通常使用 \\frac {分子} {分母} 命令产生一个分数，分数可嵌套。 便捷情况可直接输入 \\frac ab 来快速生成一个 \\frac ab 。 如果分式很复杂，亦可使用 分子 \\over 分母 命令，此时分数仅有一层。 分数示例 {% math %} \\frac{a-1}{b-1} \\quad and \\quad {a+1 \\over b+1} {% endmath %} \\frac{a-1}{b-1} \\quad and \\quad {a+1 \\over b+1} 注意: 用\\quad添加空格 两种除法\\frac和\\over，其中\\over只有一层 如何输入开方 使用 \\sqrt [根指数，省略时为2] {被开方数} 命令输入开方。 开方使用示例 {% math %} \\sqrt[]{2} \\quad and \\quad \\sqrt[n]{3} {% endmath %} \\sqrt[]{2} \\quad and \\quad \\sqrt[n]{3} 如何输入省略号 数学公式中常见的省略号有两种，\\ldots 表示与文本底线对齐的省略号，\\cdots 表示与文本中线对齐的省略号。 省略号示例: {% math %} f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots},x_n) = x_1^2+x_2^2+\\underbrace{\\cdots}_{\\rm cdots}+x_n^2 {% endmath %} f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots},x_n) = x_1^2+x_2^2+\\underbrace{\\cdots}_{\\rm cdots}+x_n^2 如何输入矢量 使用 \\vec{矢量} 来自动产生一个矢量。也可以使用 \\overrightarrow 等命令自定义字母上方的符号。 {% math %} \\vec{a} \\cdot \\vec{b} = 0 {% endmath %} \\vec{a} \\cdot \\vec{b} = 0 {% math %} \\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy} {% endmath %} \\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy} 如何输入积分 使用 \\int_积分下限^积分上限 {被积表达式} 来输入一个积分。 \\int_0^1 {x^2} \\, {\\rm d}x \\int_0^1 {x^2} \\, {\\rm d}x 本例中 \\, 和 {\\rm d} 部分可省略，但建议加入，能使式子更美观。 如何输入极限运算 使用 \\lim_{变量 \\to 表达式} 表达式 来输入一个极限。如有需求，可以更改 \\to 符号至任意符号。 {% math %} \\lim_{n \\to +\\infty}{\\frac{1}{n(n+1)}} \\quad and \\quad \\lim_{x \\leftarrow \\text{示例}}{\\frac {1}{n(n+1)}} {% endmath %} \\lim_{n \\to +\\infty}{\\frac{1}{n(n+1)}} \\quad and \\quad \\lim_{x \\leftarrow \\text{示例}}{\\frac {1}{n(n+1)}} 如何输入累加、累乘、并集、交集运算 使用 \\sum_{下标表达式}^{上标表达式} {累加表达式} 来输入一个累加。 与之类似，使用 \\prod \\bigcup \\bigcap 来分别输入累乘、并集和交集。 此类符号在行内显示时上下标表达式将会移至右上角和右下角。 {% math %} \\sum_{i=1}^{n}{\\frac{1}{i^2}} \\quad and \\quad \\prod_{i=1}^{n}{\\frac{1}{i^2}} \\quad and \\quad \\bigcup_{i=1}^{2}{R} \\quad and \\quad \\bigcap_{i=1}^{2}{R} {% endmath %} \\sum_{i=1}^{n}{\\frac{1}{i^2}} \\quad and \\quad \\prod_{i=1}^{n}{\\frac{1}{i^2}} \\quad and \\quad \\bigcup_{i=1}^{2}{R} \\quad and \\quad \\bigcap_{i=1}^{2}{R} 如何输入希腊字母 输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母。 对于大写希腊字母与现有字母相同的，直接输入大写字母即可。 输入 显示 输入 显示 输入 显示 输入 显示 \\alpha \\alpha A A \\beta \\beta B B \\gamma \\gamma \\Gamma \\Gamma \\delta \\delta \\Delta \\Delta \\epsilon \\epsilon E E \\zeta \\zeta Z Z \\eta \\eta H H \\theta \\theta \\Theta \\Theta \\iota \\iota I I \\kappa \\kappa K K \\lambda \\lambda \\Lambda \\Lambda \\mu \\mu M M \\nu \\nu N N \\xi \\xi \\Xi \\Xi o o O O \\pi \\pi \\Pi \\Pi \\rho \\rho P P \\sigma \\sigma \\Sigma \\Sigma \\tau \\tau T T \\upsilon \\upsilon \\Upsilon \\Upsilon \\phi \\phi \\Phi \\Phi \\chi \\chi X X \\psi \\psi \\Psi \\Psi \\omega \\omega \\Omega \\Omega 部分字母有变量专用形式，以 \\var- 开头。 小写形式 大写形式 变量形式 显示 \\epsilon E \\varepsilon \\epsilon \\mid E \\mid \\varepsilon \\theta \\Theta \\vartheta \\theta \\mid \\Theta \\mid \\vartheta \\rho P \\varrho \\rho \\mid P \\mid \\varrho \\sigma \\Sigma \\varsigma \\sigma \\mid \\Sigma \\mid \\varsigma \\phi \\Phi \\varphi \\phi \\mid \\Phi \\mid \\varphi 输入其他特殊字符 若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令。 若找不到需要的符号，使用 \\rm{Detexify^2} 来画出想要的符号。 关系运算符号 输入 显示 输入 显示 输入 显示 输入 显示 \\pm \\pm \\times \\times \\div \\div \\mid \\mid \\nmid \\nmid \\cdot \\cdot \\circ \\circ \\ast \\ast \\bigodot \\bigodot \\bigotimes \\bigotimes \\bigoplus \\bigoplus \\leq \\leq \\geq \\geq \\neq \\neq \\approx \\approx \\equiv \\equiv \\sum \\sum \\prod \\prod \\coprod \\coprod \\backslash \\backslash 集合运算符号 输入 显示 输入 显示 输入 显示 \\emptyset \\emptyset \\in \\in \\notin \\notin \\subset \\subset \\supset \\supset \\subseteq \\subseteq \\supseteq \\supseteq \\bigcap \\bigcap \\bigcup \\bigcup \\bigvee \\bigvee \\bigwedge \\bigwedge \\biguplus \\biguplus 对数运算符号 输入 显示 输入 显示 输入 显示 \\log \\log \\lg \\lg \\ln \\ln 三角运算符 输入 显示 输入 显示 输入 显示 30^\\circ 30^\\circ \\bot \\bot \\angle A \\angle A \\sin \\sin \\cos \\cos \\tan \\tan \\csc \\csc \\sec \\sec \\cot \\cot 微积分运算符 输入 显示 输入 显示 输入 显示 \\int \\int \\iint \\iint \\iiint \\iiint \\iiiint 不支持 \\oint \\oint \\prime \\prime \\lim \\lim \\infty \\infty \\nabla \\nabla 逻辑运算符 输入 显示 输入 显示 输入 显示 \\because \\because \\therefore \\therefore \\forall \\forall \\exists \\exists \\not\\subset \\not\\subset \\not \\not \\not> \\not> \\not= \\not= 带帽符号 输入 显示 输入 显示 \\hat{xy} \\hat{xy} \\widehat{xyz} \\widehat{xyz} \\tilde{xy} \\tilde{xy} \\widetilde{xyz} \\widetilde{xyz} \\check{x} \\check{x} \\breve{y} \\breve{y} \\grave{x} \\grave{x} \\acute{y} \\acute{y} 连线符号 输入 显示 \\fbox{a+b+c+d} \\fbox{a+b+c+d} \\overleftarrow{a+b+c+d} \\overleftarrow{a+b+c+d} \\overrightarrow{a+b+c+d} \\overrightarrow{a+b+c+d} \\overleftrightarrow{a+b+c+d} \\overleftrightarrow{a+b+c+d} \\underleftarrow{a+b+c+d} \\underleftarrow{a+b+c+d} \\underrightarrow{a+b+c+d} \\underrightarrow{a+b+c+d} \\underleftrightarrow{a+b+c+d} \\underleftrightarrow{a+b+c+d} \\overline{a+b+c+d} \\overline{a+b+c+d} \\underline{a+b+c+d} \\underline{a+b+c+d} \\overbrace{a+b+c+d}^{Sample} \\overbrace{a+b+c+d}^{Sample} \\underbrace{a+b+c+d}_{Sample} \\underbrace{a+b+c+d}_{Sample} \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} \\underrightarrow{1℃/min} \\underrightarrow{1^\\circ {\\bf C}/min} 箭头符号 推荐使用符号 输入 显示 输入 显示 输入 显示 \\to \\to \\mapsto \\mapsto \\implies \\implies \\iff \\iff \\impliedby \\impliedby 其他可用符号 输入 显示 输入 显示 \\uparrow \\uparrow \\Uparrow \\Uparrow \\downarrow \\downarrow \\Downarrow \\Downarrow \\leftarrow \\leftarrow \\Leftarrow \\Leftarrow \\rightarrow \\rightarrow \\Rightarrow \\Rightarrow \\leftrightarrow \\leftrightarrow \\Leftrightarrow \\Leftrightarrow \\longleftarrow \\longleftarrow \\Longleftarrow \\Longleftarrow \\longrightarrow \\longrightarrow \\Longrightarrow \\Longrightarrow \\longleftrightarrow \\longleftrightarrow \\Longleftrightarrow \\Longleftrightarrow 如何转换字体 若要对公式的某一部分字符进行字体转换，可以用 {\\字体 {需转换的部分字符}} 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为意大利体 \\it {italic} 。 示例中 全部大写 的字体仅大写可用。 输入 说明 显示 输入 说明 显示 \\rm 罗马体 \\rm{Sample} \\cal 花体 不支持 \\it 意大利体 \\it{Sample} \\Bbb 黑板粗体 \\Bbb{SAMPLE} \\bf 粗体 \\bf{Sample} \\mit 数学斜体 不支持 \\sf 等线体 \\sf{Sample} \\scr 手写体 不支持 \\tt 打字机体 \\tt{Sample} \\frak 旧德式字体 \\frak{Sample} - 转换字体十分常用，例如在积分中： \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\int_0^1 x^2 dx & \\int_0^1 x^2 \\,{\\rm d}x \\end{array} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\int_0^1 x^2 dx & \\int_0^1 x^2 \\,{\\rm d}x \\end{array} 注意比较两个式子间 dx与 {\\rm d} x 的不同。 使用 \\operatorname 命令也可以达到相同的效果，详见 定义新的符号 \\operatorname 。 大括号和行标的使用 使用 \\left 和 \\right 来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} 。 在每个公式末尾前使用 \\tag{行标} 来实现行标。 {% math %} f\\left( \\left[ \\frac{1+\\{x,y\\}} {\\left( \\frac{x}{y}+ \\frac{y}{x} \\right) (u+1) } +a \\right] ^{3/2} \\right) \\tag{公式行标} {% endmath %} f\\left( \t\\left[ \t\t\\frac{1+\\{x,y\\}} \t\t {\\left( \t\t \\frac{x}{y}+ \t\t \\frac{y}{x} \t\t \\right) \t\t (u+1) \t\t }\t\t \t\t+a \t\\right] \t^{3/2} \\right) \\tag{公式行标} 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \\left. 或 \\right. 来放一个\"影子\"括号： {% math %} \\begin{aligned} a = &\\left(1+2+3+\\cdots \\right. \\\\ &\\cdots+\\left. \\infty-2+\\infty-1+\\infty \\right) \\end{aligned} {% endmath %} \\begin{aligned} a = &\\left(1+2+3+\\cdots \\right. \\\\ &\\cdots+\\left. \\infty-2+\\infty-1+\\infty \\right) \\end{aligned} 如果你需要将行内显示的分隔符也变大，可以使用 \\middle 命令： {% math %} \\left\\langle q \\middle\\| \\frac{\\frac{x}{y}}{\\frac{u}{v}} \\middle| p \\right\\rangle {% endmath %} \\left\\langle q \\middle\\| \\frac{\\frac{x}{y}}{\\frac{u}{v}} \\middle| p \\right\\rangle 其他命令 定义新的符号 查询 关于此命令的定义 和 关于此命令的讨论 来进一步了解此命令。 {% math %} \\operatorname{Symbol} A {% endmath %} \\operatorname{Symbol} A 添加注释文字 在 \\text {文字} 中仍可以使用 $公式$ 插入其它公式。 {% math %} f(n)=\\begin{cases} n/2, & \\text{if $n$ is even} \\\\ 3n+1, & \\text{if $n$ is odd} \\end{cases} {% endmath %} f(n)=\\begin{cases} n/2, & \\text{if $n$ is even} \\\\ 3n+1, & \\text{if $n$ is odd} \\end{cases} 在字符间加入空格 有四种宽度的空格可以使用： \\,、\\;、\\quad 和 \\qquad 。 {% math %} a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b \\mid {% endmath %} a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b \\mid 当然，使用 \\text {n个空格} 也可以达到同样效果。 更改文字颜色 使用 \\color{颜色}{文字} 来更改特定的文字颜色。 更改文字颜色 需要浏览器支持 ，如果浏览器不知道你所需的颜色，那么文字将被渲染为黑色。 对于较旧的浏览器（HTML4与CSS2），以下颜色是被支持的： 输入 显示 输入 显示 black \\color{black}{text} grey \\color{grey}{text} silver \\color{silver}{text} white \\color{white}{text} maroon \\color{maroon}{text} red \\color{red}{text} yellow \\color{yellow}{text} lime \\color{lime}{text} olive \\color{olive}{text} green \\color{green}{text} teal \\color{teal}{text} auqa \\color{auqa}{text} blue \\color{blue}{text} navy \\color{navy}{text} purple \\color{purple}{text} fuchsia \\color{fuchsia}{text} 对于较新的浏览器（HTML5与CSS3），额外的124种颜色将被支持： 输入 \\color {#rgb} {text} 来自定义更多的颜色，其中 #rgb 的 r g b 可输入 0-9 和 a-f 来表示红色、绿色和蓝色的纯度（饱和度）。 {% math %} \\begin{array}{|rrrrrrrr|}\\hline \\verb+#000+ & \\color{#000}{text} & & & \\verb+#00F+ & \\color{#00F}{text} & & \\\\ & & \\verb+#0F0+ & \\color{#0F0}{text} & & & \\verb+#0FF+ & \\color{#0FF}{text}\\\\ \\verb+#F00+ & \\color{#F00}{text} & & & \\verb+#F0F+ & \\color{#F0F}{text} & & \\\\ & & \\verb+#FF0+ & \\color{#FF0}{text} & & & \\verb+#FFF+ & \\color{#FFF}{text}\\\\ \\hline \\end{array} {% endmath %} \\begin{array}{|rrrrrrrr|}\\hline \\verb+#000+ & \\color{#000}{text} & & & \\verb+#00F+ & \\color{#00F}{text} & & \\\\ & & \\verb+#0F0+ & \\color{#0F0}{text} & & & \\verb+#0FF+ & \\color{#0FF}{text}\\\\ \\verb+#F00+ & \\color{#F00}{text} & & & \\verb+#F0F+ & \\color{#F0F}{text} & & \\\\ & & \\verb+#FF0+ & \\color{#FF0}{text} & & & \\verb+#FFF+ & \\color{#FFF}{text}\\\\ \\hline \\end{array} {% math %} \\begin{array}{|rrrrrrrr|} \\hline \\verb+#000+ & \\color{#000}{text} & \\verb+#005+ & \\color{#005}{text} & \\verb+#00A+ & \\color{#00A}{text} & \\verb+#00F+ & \\color{#00F}{text} \\\\ \\verb+#500+ & \\color{#500}{text} & \\verb+#505+ & \\color{#505}{text} & \\verb+#50A+ & \\color{#50A}{text} & \\verb+#50F+ & \\color{#50F}{text} \\\\ \\verb+#A00+ & \\color{#A00}{text} & \\verb+#A05+ & \\color{#A05}{text} & \\verb+#A0A+ & \\color{#A0A}{text} & \\verb+#A0F+ & \\color{#A0F}{text} \\\\ \\verb+#F00+ & \\color{#F00}{text} & \\verb+#F05+ & \\color{#F05}{text} & \\verb+#F0A+ & \\color{#F0A}{text} & \\verb+#F0F+ & \\color{#F0F}{text} \\\\ \\hline \\verb+#080+ & \\color{#080}{text} & \\verb+#085+ & \\color{#085}{text} & \\verb+#08A+ & \\color{#08A}{text} & \\verb+#08F+ & \\color{#08F}{text} \\\\ \\verb+#580+ & \\color{#580}{text} & \\verb+#585+ & \\color{#585}{text} & \\verb+#58A+ & \\color{#58A}{text} & \\verb+#58F+ & \\color{#58F}{text} \\\\ \\verb+#A80+ & \\color{#A80}{text} & \\verb+#A85+ & \\color{#A85}{text} & \\verb+#A8A+ & \\color{#A8A}{text} & \\verb+#A8F+ & \\color{#A8F}{text} \\\\ \\verb+#F80+ & \\color{#F80}{text} & \\verb+#F85+ & \\color{#F85}{text} & \\verb+#F8A+ & \\color{#F8A}{text} & \\verb+#F8F+ & \\color{#F8F}{text} \\\\ \\hline \\verb+#0F0+ & \\color{#0F0}{text} & \\verb+#0F5+ & \\color{#0F5}{text} & \\verb+#0FA+ & \\color{#0FA}{text} & \\verb+#0FF+ & \\color{#0FF}{text} \\\\ \\verb+#5F0+ & \\color{#5F0}{text} & \\verb+#5F5+ & \\color{#5F5}{text} & \\verb+#5FA+ & \\color{#5FA}{text} & \\verb+#5FF+ & \\color{#5FF}{text} \\\\ \\verb+#AF0+ & \\color{#AF0}{text} & \\verb+#AF5+ & \\color{#AF5}{text} & \\verb+#AFA+ & \\color{#AFA}{text} & \\verb+#AFF+ & \\color{#AFF}{text} \\\\ \\verb+#FF0+ & \\color{#FF0}{text} & \\verb+#FF5+ & \\color{#FF5}{text} & \\verb+#FFA+ & \\color{#FFA}{text} & \\verb+#FFF+ & \\color{#FFF}{text} \\\\ \\hline \\end{array} {% endmath %} \\begin{array}{|rrrrrrrr|} \\hline \\verb+#000+ & \\color{#000}{text} & \\verb+#005+ & \\color{#005}{text} & \\verb+#00A+ & \\color{#00A}{text} & \\verb+#00F+ & \\color{#00F}{text} \\\\ \\verb+#500+ & \\color{#500}{text} & \\verb+#505+ & \\color{#505}{text} & \\verb+#50A+ & \\color{#50A}{text} & \\verb+#50F+ & \\color{#50F}{text} \\\\ \\verb+#A00+ & \\color{#A00}{text} & \\verb+#A05+ & \\color{#A05}{text} & \\verb+#A0A+ & \\color{#A0A}{text} & \\verb+#A0F+ & \\color{#A0F}{text} \\\\ \\verb+#F00+ & \\color{#F00}{text} & \\verb+#F05+ & \\color{#F05}{text} & \\verb+#F0A+ & \\color{#F0A}{text} & \\verb+#F0F+ & \\color{#F0F}{text} \\\\ \\hline \\verb+#080+ & \\color{#080}{text} & \\verb+#085+ & \\color{#085}{text} & \\verb+#08A+ & \\color{#08A}{text} & \\verb+#08F+ & \\color{#08F}{text} \\\\ \\verb+#580+ & \\color{#580}{text} & \\verb+#585+ & \\color{#585}{text} & \\verb+#58A+ & \\color{#58A}{text} & \\verb+#58F+ & \\color{#58F}{text} \\\\ \\verb+#A80+ & \\color{#A80}{text} & \\verb+#A85+ & \\color{#A85}{text} & \\verb+#A8A+ & \\color{#A8A}{text} & \\verb+#A8F+ & \\color{#A8F}{text} \\\\ \\verb+#F80+ & \\color{#F80}{text} & \\verb+#F85+ & \\color{#F85}{text} & \\verb+#F8A+ & \\color{#F8A}{text} & \\verb+#F8F+ & \\color{#F8F}{text} \\\\ \\hline \\verb+#0F0+ & \\color{#0F0}{text} & \\verb+#0F5+ & \\color{#0F5}{text} & \\verb+#0FA+ & \\color{#0FA}{text} & \\verb+#0FF+ & \\color{#0FF}{text} \\\\ \\verb+#5F0+ & \\color{#5F0}{text} & \\verb+#5F5+ & \\color{#5F5}{text} & \\verb+#5FA+ & \\color{#5FA}{text} & \\verb+#5FF+ & \\color{#5FF}{text} \\\\ \\verb+#AF0+ & \\color{#AF0}{text} & \\verb+#AF5+ & \\color{#AF5}{text} & \\verb+#AFA+ & \\color{#AFA}{text} & \\verb+#AFF+ & \\color{#AFF}{text} \\\\ \\verb+#FF0+ & \\color{#FF0}{text} & \\verb+#FF5+ & \\color{#FF5}{text} & \\verb+#FFA+ & \\color{#FFA}{text} & \\verb+#FFF+ & \\color{#FFF}{text} \\\\ \\hline \\end{array} 添加删除线(katex 部分支持) 在公式内使用 \\require{cancel} 来允许 片段删除线 的显示。 声明片段删除线后，使用 \\cancel{字符}、\\bcancel{字符}、\\xcancel{字符} 和 \\cancelto{字符} 来实现各种片段删除线效果。 {% math %} \\begin{array}{rl} \\verb|y+\\cancel{x}| & y+\\cancel{x} \\\\ \\verb|\\cancel{y+x}| & \\cancel{y+x} \\\\ \\verb|y+\\bcancel{x}| & y+\\bcancel{x} \\\\ \\verb|y+\\xcancel{x}| & y+\\xcancel{x} \\\\ \\verb|y+\\cancelto{0}{x}| & \\text{不支持} \\\\ \\verb+\\frac{1\\cancel9}{\\cancel95} = \\frac15+& \\frac{1\\cancel9}{\\cancel95} = \\frac15 \\\\ \\end{array} {% endmath %} \\begin{array}{rl} \\verb|y+\\cancel{x}| & y+\\cancel{x} \\\\ \\verb|\\cancel{y+x}| & \\cancel{y+x} \\\\ \\verb|y+\\bcancel{x}| & y+\\bcancel{x} \\\\ \\verb|y+\\xcancel{x}| & y+\\xcancel{x} \\\\ \\verb|y+\\cancelto{0}{x}| & \\text{不支持} \\\\ \\verb+\\frac{1\\cancel9}{\\cancel95} = \\frac15+& \\frac{1\\cancel9}{\\cancel95} = \\frac15 \\\\ \\end{array} 下面使用 \\require{enclose} 来允许 整段删除线 的显示。(katex不支持) 声明整段删除线后，使用 \\enclose{删除线效果}{字符} 来实现各种整段删除线效果。 其中，删除线效果有 horizontalstrike、verticalstrike、updiagonalstrike 和 downdiagonalstrike，可叠加使用。 {% math %} \\require{enclose}\\begin{array}{rl} \\verb|\\enclose{horizontalstrike}{x+y}| & \\enclose{horizontalstrike}{x+y}\\\\ \\verb|\\enclose{verticalstrike}{\\frac xy}| & \\enclose{verticalstrike}{\\frac xy}\\\\ \\verb|\\enclose{updiagonalstrike}{x+y}| & \\enclose{updiagonalstrike}{x+y}\\\\ \\verb|\\enclose{downdiagonalstrike}{x+y}| & \\enclose{downdiagonalstrike}{x+y}\\\\ \\verb|\\enclose{horizontalstrike,updiagonalstrike}{x+y}| & \\enclose{horizontalstrike,updiagonalstrike}{x+y}\\\\ \\end{array} {% endmath %} 此外， \\enclose 命令还可以产生包围的边框和圆等，参见 MathML Menclose Documentation 以查看更多效果。 var className='atoc';"},"1-Chapter/2-矩阵使用参考_矩阵方式.html":{"url":"1-Chapter/2-矩阵使用参考_矩阵方式.html","title":"第一章 第2节：矩阵使用参考_矩阵方式","keywords":"","body":"第一章 第2节：矩阵使用参考 如何输入无边框矩阵 {% math %} \\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix} {% endmath %} \\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix} 如何输入边框矩阵 在开头将 matrix 替换为 pmatrix bmatrix Bmatrix vmatrix Vmatrix 。 matrix pmatrix bmatrix Bmatrix vmatrix Vmatrix \\begin{matrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{matrix} \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{pmatrix} \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{bmatrix} \\begin{Bmatrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{Bmatrix} \\begin{vmatrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{vmatrix} \\begin{Vmatrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{Vmatrix} 如何输入带省略号的矩阵 使用 \\cdots \\cdots, \\ddots \\ddots , \\vdots \\vdots 来输入省略符号。 {% math %} \\begin{pmatrix} 1 & a_1 & a_1^2 & \\cdots & a_1^n \\\\ 1 & a_2 & a_2^2 & \\cdots & a_2^n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & a_m & a_m^2 & \\cdots & a_m^n \\\\ \\end{pmatrix} {% endmath %} \\begin{pmatrix} 1 & a_1 & a_1^2 & \\cdots & a_1^n \\\\ 1 & a_2 & a_2^2 & \\cdots & a_2^n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & a_m & a_m^2 & \\cdots & a_m^n \\\\ \\end{pmatrix} 如何输入带分割符号的矩阵 详见\"数组使用参考\"。 {% math %} \\left[ \\begin{array}{cc|c} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ \\end{array} \\right] {% endmath %} \\left[ \\begin{array}{cc|c} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ \\end{array} \\right] 其中 cc|c 代表在一个三列矩阵中的第二和第三列之间插入分割线。 如何输入行中矩阵 若想在一行内显示矩阵， 使用\\bigl(\\begin{smallmatrix} ... \\end{smallmatrix}\\bigr)。 这是一个行中矩阵的示例\\bigl( \\begin{smallmatrix} a & b \\\\ c & d \\\\ \\end{smallmatrix} \\bigr) var className='atoc';"},"1-Chapter/2-矩阵使用参考_数组方式.html":{"url":"1-Chapter/2-矩阵使用参考_数组方式.html","title":"第一章 第2节：矩阵使用参考_数组方式","keywords":"","body":"第一章 第2节：矩阵使用参考 如何输入无框矩阵 {% math %} \\left. \\begin{array}{ccc} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ \\end{array} \\right. {% endmath %} \\left. \\begin{array}{ccc} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ \\end{array} \\right. 如何输入边框矩阵 将\\left.替换成\\left(、\\left[、\\left\\{、\\left|、\\left\\|，\\right.同理 matrix pmatrix bmatrix Bmatrix vmatrix Vmatrix \\left. \\begin{array}{cc} 1 & 2 \\\\ 3 & 4 \\\\ \\end{array} \\right. \\left( \\begin{array}{cc} 1 & 2 \\\\ 3 & 4 \\\\ \\end{array} \\right) \\left[ \\begin{array}{cc} 1 & 2 \\\\ 3 & 4 \\\\ \\end{array} \\right] \\left\\{ \\begin{array}{cc} 1 & 2 \\\\ 3 & 4 \\\\ \\end{array} \\right\\} \\left| \\begin{array}{cc} 1 & 2 \\\\ 3 & 4 \\\\ \\end{array} \\right| \\left\\| \\begin{array}{cc} 1 & 2 \\\\ 3 & 4 \\\\ \\end{array} \\right\\| 如何输入带省略符号的矩阵 {% math %} \\left( \\begin{array}{cccc} 1 & a_1 & a_1^2 & \\cdots & a_1^n \\\\ 1 & a_2 & a_2^2 & \\cdots & a_2^n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & a_m & a_m^2 & \\cdots & a_m^n \\\\ \\end{array} \\right) {% endmath %} \\left( \\begin{array}{cccc} 1 & a_1 & a_1^2 & \\cdots & a_1^n \\\\ 1 & a_2 & a_2^2 & \\cdots & a_2^n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & a_m & a_m^2 & \\cdots & a_m^n \\\\ \\end{array} \\right) 如何输入带分割符号的矩阵 详见\"数组使用参考\"。 {% math %} \\left[ \\begin{array}{cc|c} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ \\end{array} \\right] {% endmath %} \\left[ \\begin{array}{cc|c} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ \\end{array} \\right] 其中 cc|c 代表在一个三列矩阵中的第二和第三列之间插入分割线。 如何输入行中矩阵 行中矩阵{% math %}\\left( \\begin{array}{cc} 1 & 2 \\\\ 4 & 5 \\\\ \\end{array} \\right){% endmath %} 行中矩阵\\left( \\begin{array}{cc} 1 & 2 \\\\ 4 & 5 \\\\ \\end{array} \\right) var className='atoc';"},"1-Chapter/3-方程式序列使用参考.html":{"url":"1-Chapter/3-方程式序列使用参考.html","title":"第一章 第3节：方程式序列使用参考","keywords":"","body":"第一章 第3节：方程式序列使用参考 如何输入方程式序列 (katex不支持{align}，用{aligned}代替) 人们经常想要一列整齐且居中的方程式序列。使用 \\begin{align}…\\end{align} 来创造一列方程式，其中在每行结尾处使用 \\\\ 。 {% math %} \\begin{aligned} \\sqrt{37} & = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ & = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ & \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\\\ \\end{aligned} {% endmath %} \\begin{aligned} \\sqrt{37} & = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ & = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ & \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\\\ \\end{aligned} 在方程式序列的每行注明原因 (katex不支持{align}，用{aligned}代替) 在 {align} 中灵活组合 \\text 和 \\tag 语句。\\tag 语句编号优先级高于自动编号。 {% math %} \\begin{aligned} v+w & = 0 & \\text{Given} \\qquad\\qquad (1) \\\\ -w & = -w+0 & \\text{additive identity} \\qquad\\qquad (2) \\\\ -w+0 & = -w+(v+w) & \\text{equations(1) and (2)} \\qquad\\qquad (7) \\\\ \\end{aligned} {% endmath %} \\begin{aligned} v+w & = 0 & \\text{Given} \\qquad\\qquad (1) \\\\ -w & = -w+0 & \\text{additive identity} \\qquad\\qquad (2) \\\\ -w+0 & = -w+(v+w) & \\text{equations(1) and (2)} \\qquad\\qquad (7) \\\\ \\end{aligned} 本例中第一、第二行的自动编号被 \\tag 语句覆盖，第三行的编号为自动编号。 注意: 因为 {aligned} 中不能使用\\tag，所以直接用 \\qquad\\qquad (number) 替换掉了。 var className='atoc';"},"1-Chapter/4-条件表达式使用参考.html":{"url":"1-Chapter/4-条件表达式使用参考.html","title":"第一章 第4节：条件表达式使用参考","keywords":"","body":"第一章 第4节：条件表达式使用参考 如何输入一个条件表达式 使用 begin{cases} 来创造一组条件表达式，在每一行条件中插入 & 来指定需要对齐的内容，并在每一行结尾处使用 \\\\，以 end{cases} 结束。 {% math %} f(n) = \\begin{cases} n/2, & \\text{if $n$ is even} \\\\ 3n+1,& \\text{if $n$ is odd} \\\\ \\end{cases} {% endmath %} f(n) = \\begin{cases} n/2, & \\text{if $n$ is even} \\\\ 3n+1,& \\text{if $n$ is odd} \\\\ \\end{cases} 如何输入一个左侧对齐的条件表达式 若想让文字在 左侧对齐显示 ，则有如下方式： {% math %} \\left. \\begin{array}{l} \\text{if $n$ is even:} & n/2 \\\\ \\text{if $n$ is odd:} & 3n+1 \\\\ \\end{array} \\right\\} =f(n) {% endmath %} \\left. \\begin{array}{l} \\text{if $n$ is even:} & n/2 \\\\ \\text{if $n$ is odd:} & 3n+1 \\\\ \\end{array} \\right\\} =f(n) 如何使条件表达式适配行高 在一些情况下，条件表达式中某些行的行高为非标准高度，此时使用 \\\\[2ex] 语句代替该行末尾的 \\\\ 来让编辑器适配。 不适配时效果 {% math %} f(n) = \\begin{cases} \\frac{n}{2}, & \\text{if $n$ is even} \\\\ 3n+1, & \\text{if $n$ is odd} \\end{cases} {% endmath %} f(n) = \\begin{cases} \\frac{n}{2}, & \\text{if $n$ is even} \\\\ 3n+1, & \\text{if $n$ is odd} \\end{cases} 适配时效果 f(n) = \\begin{cases} \\frac{n}{2}, & \\text{if $n$ is even} \\\\[2ex] 3n+1, & \\text{if $n$ is odd} \\end{cases} f(n) = \\begin{cases} \\frac{n}{2}, & \\text{if $n$ is even} \\\\[2ex] 3n+1, & \\text{if $n$ is odd} \\end{cases} 一个 [ex] 指一个 \"X-Height\"，即x字母高度。可以根据情况指定多个 [ex]，如 [3ex]、[4ex] 等。 其实可以在任何地方使用 \\\\[2ex] 语句，只要你觉得合适。 var className='atoc';"},"1-Chapter/5-数组与表格使用参考.html":{"url":"1-Chapter/5-数组与表格使用参考.html","title":"第一章 第5节：数组与表格使用参考","keywords":"","body":"第一章 第5节：数组与表格使用参考 如何输入一个数组或表格 通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。数组和表格均以 begin{array} 开头，并在其后定义列数及每一列的文本对齐属性，c l r 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 | ，若要插入水平分割线，在下一行输入前插入 \\hline 。与矩阵相似，每行元素间均须要插入 & ，每行元素以 \\\\ 结尾，最后以 end{array} 结束数组。 {% math %} \\begin{array}{c|lcr} n & \\text{左对齐} & \\text{居中对齐} & \\text{右对齐} \\\\ \\hline 1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array} {% endmath %} \\begin{array}{c|lcr} n & \\text{左对齐} & \\text{居中对齐} & \\text{右对齐} \\\\ \\hline 1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array} 如何输入一个嵌套的数组或表格 多个数组/表格可 互相嵌套 并组成一组数组/一组表格。 {% math %} \\begin{array}{c} \\begin{array}{cc} \\begin{array}{c|cccc} \\text{min} & 0 & 1 & 2 & 3\\\\ \\hline 0 & 0 & 0 & 0 & 0\\\\ 1 & 0 & 1 & 1 & 1\\\\ 2 & 0 & 1 & 2 & 2\\\\ 3 & 0 & 1 & 2 & 3 \\end{array} & \\begin{array}{c|cccc} \\text{max}&0&1&2&3\\\\ \\hline 0 & 0 & 1 & 2 & 3\\\\ 1 & 1 & 1 & 2 & 3\\\\ 2 & 2 & 2 & 2 & 3\\\\ 3 & 3 & 3 & 3 & 3 \\end{array} \\end{array} \\\\ \\begin{array}{c|cccc} \\Delta&0&1&2&3\\\\ \\hline 0 & 0 & 1 & 2 & 3\\\\ 1 & 1 & 0 & 1 & 2\\\\ 2 & 2 & 1 & 0 & 1\\\\ 3 & 3 & 2 & 1 & 0 \\end{array} \\end{array} {% endmath %} \\begin{array}{c} \\begin{array}{cc} \\begin{array}{c|cccc} \\text{min} & 0 & 1 & 2 & 3\\\\ \\hline 0 & 0 & 0 & 0 & 0\\\\ 1 & 0 & 1 & 1 & 1\\\\ 2 & 0 & 1 & 2 & 2\\\\ 3 & 0 & 1 & 2 & 3 \\end{array} & \\begin{array}{c|cccc} \\text{max}&0&1&2&3\\\\ \\hline 0 & 0 & 1 & 2 & 3\\\\ 1 & 1 & 1 & 2 & 3\\\\ 2 & 2 & 2 & 2 & 3\\\\ 3 & 3 & 3 & 3 & 3 \\end{array} \\end{array} \\\\ \\begin{array}{c|cccc} \\Delta&0&1&2&3\\\\ \\hline 0 & 0 & 1 & 2 & 3\\\\ 1 & 1 & 0 & 1 & 2\\\\ 2 & 2 & 1 & 0 & 1\\\\ 3 & 3 & 2 & 1 & 0 \\end{array} \\end{array} 如何输入一个方程组 使用 \\begin{array}…\\end{array} 和 \\left\\{…\\right. 来创建一个方程组。 {% math %} \\left\\{ \\begin{array}{c} a_1x+b_1y+c_1z = d_1 \\\\ a_2x+b_2y+c_2z = d_2 \\\\ a_3x+b_3y+c_3z = d_3 \\\\ \\end{array} \\right. {% endmath %} \\left\\{ \\begin{array}{c} a_1x+b_1y+c_1z = d_1 \\\\ a_2x+b_2y+c_2z = d_2 \\\\ a_3x+b_3y+c_3z = d_3 \\\\ \\end{array} \\right. 或者使用条件表达式组 \\begin{cases}…\\end{cases} 来实现相同效果： {% math %} \\begin{cases} a_1x+b_1y+c_1z = d_1 \\\\ a_2x+b_2y+c_2z = d_2 \\\\ a_3x+b_3y+c_3z = d_3 \\\\ \\end{cases} {% endmath %} \\begin{cases} a_1x+b_1y+c_1z = d_1 \\\\ a_2x+b_2y+c_2z = d_2 \\\\ a_3x+b_3y+c_3z = d_3 \\\\ \\end{cases} var className='atoc';"},"1-Chapter/6-连分数使用参考.html":{"url":"1-Chapter/6-连分数使用参考.html","title":"第一章 第6节：连分数使用参考","keywords":"","body":"第一章 第6节：连分数使用参考 就像输入分式时使用 \\frac 一样，使用 \\cfrac 来创建一个连分数。 {% math %} x = a_0 + \\cfrac{1^2}{a_1 + \\cfrac{2^2}{a_2 + \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots }}}} {% endmath %} x = a_0 + \\cfrac{1^2}{a_1 + \\cfrac{2^2}{a_2 + \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots }}}} 不要使用普通的 \\frac 或 \\over 来创建，否则会看起来 很恶心 。 {% math %} x = a_0 + \\frac{1^2}{a_1 + \\frac{2^2}{a_2 + \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots }}}} {% endmath %} x = a_0 + \\frac{1^2}{a_1 + \\frac{2^2}{a_2 + \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots }}}} 当然，你可以使用 \\frac 来表达连分数的 紧缩记法 。 {% math %} x = a_0 + \\frac{1^2}{a_1+} + \\frac{2^2}{a_2+} + \\frac{3^2}{a_3+} + \\frac{4^4}{a_4+} + \\cdots {% endmath %} x = a_0 + \\frac{1^2}{a_1+} + \\frac{2^2}{a_2+} + \\frac{3^2}{a_3+} + \\frac{4^4}{a_4+} + \\cdots 连分数通常都太大以至于不易排版，所以建议在连分数前后声明 $$ 符号，或使用像 [a0;a1,a2,a3,…] 一样的紧缩记法。 var className='atoc';"},"1-Chapter/7-交换图表使用参考.html":{"url":"1-Chapter/7-交换图表使用参考.html","title":"第一章 第7节：交换图表使用参考","keywords":"","body":"第一章 第7节：交换图表使用参考 如何输入一个交换图表(katex不支持，mathjax支持) 使用一行 $ \\require{AMScd} $ 语句来允许交换图表的显示。 声明交换图表后，语法与矩阵相似，在开头使用 begin{CD}，在结尾使用 end{CD}，在中间插入图表元素，每个元素之间插入 & ，并在每行结尾处使用 \\\\ 。 {% math %} \\require{AMScd} \\begin{CD} A @>a>> B\\\\ @V b V V\\# @VV c V\\\\ C @>>d> D \\end{CD} {% endmath %} 其中，@>>> 代表右箭头、@ 代表左箭头、@VVV 代表下箭头、@AAA 代表上箭头、@= 代表水平双实线、@| 代表竖直双实线、@.代表没有箭头。 在 @>>> 的 >>> 之间任意插入文字即代表该箭头的注释文字。 {% math %} \\require{AMScd} \\begin{CD} A @>>> B @>{\\text{very long label}}>> C \\\\ @. @AAA @| \\\\ D @= E @ 在本例中， \"very long label\"自动延长了它所在箭头以及对应箭头的长度。 var className='atoc';"},"1-Chapter/8-特殊的注意事项.html":{"url":"1-Chapter/8-特殊的注意事项.html","title":"第一章 第8节：特殊的注意事项","keywords":"","body":"第一章 第8节：特殊的注意事项 在以e为底的指数函数、极限和积分中尽量不要使用 \\frac 符号：它会使整段函数看起来很怪，而且可能产生歧义。也正是因此它在专业数学排版中几乎从不出现。 横着写这些分式，中间使用斜线间隔 / （用斜线代替分数线）。 {% math %} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}& e^{i\\pi/2} \\\\ \\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx & \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\ \\end{array} {% endmath %} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}& e^{i\\pi/2} \\\\ \\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx & \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\ \\end{array} | 符号在被当作分隔符时会产生错误的间隔，因此在需要分隔时最好使用 \\mid 来代替它。 {% math %} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\{x|x^2\\in\\Bbb Z\\} & \\{x\\mid x^2\\in\\Bbb Z\\} \\\\ \\end{array} {% endmath %} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\{x|x^2\\in\\Bbb Z\\} & \\{x\\mid x^2\\in\\Bbb Z\\} \\\\ \\end{array} 使用多重积分符号时，不要多次使用 \\int 来声明，直接使用 \\iint 来表示 二重积分 ，使用 \\iiint 来表示 三重积分 等。对于无限次积分，可以用 \\int \\cdots \\int 表示。 {% math %} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\int\\int_S f(x)\\,dy\\,dx & \\iint_S f(x)\\,dy\\,dx \\\\ \\int\\int\\int_V f(x)\\,dz\\,dy\\,dx & \\iiint_V f(x)\\,dz\\,dy\\,dx \\end{array} {% endmath %} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\int\\int_S f(x)\\,dy\\,dx & \\iint_S f(x)\\,dy\\,dx \\\\ \\int\\int\\int_V f(x)\\,dz\\,dy\\,dx & \\iiint_V f(x)\\,dz\\,dy\\,dx \\end{array} 无限次积分: {% math %} \\int \\cdots \\int {% endmath %} \\int \\cdots \\int 在微分符号前加入 \\, 来插入一个小的间隔空隙；没有 \\, 符号的话，\\TeX 将会把不同的微分符号堆在一起。 {% math %} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\iiint_V f(x){\\rm d}z {\\rm d}y {\\rm d}x & \\iiint_V f(x)\\,{\\rm d}z\\,{\\rm d}y\\,{\\rm d}x \\end{array} {% endmath %} \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\iiint_V f(x){\\rm d}z {\\rm d}y {\\rm d}x & \\iiint_V f(x)\\,{\\rm d}z\\,{\\rm d}y\\,{\\rm d}x \\end{array} var className='atoc';"},"1-Chapter/9-Katex VS Mathjax.html":{"url":"1-Chapter/9-Katex VS Mathjax.html","title":"第一章 第9节：Katex VS Mathjax","keywords":"","body":"第一章 第9节：Katex VS Mathjax 实测katex-pp插件不支持的功能 少数字体 删除线(仅部分支持) ４重积分 方程式序列(需要改写成{aligned}) 交换图表 化学方程式需要单独扩展 实测mathjax-pro插件都支持以上这些功能 实测mathjax-pro插件存在的问题 公式中的中文排版错乱 行内公式位置向上偏移 导出PDF时公式模糊 用Mathjax实现化学方程式: https://mhchem.github.io/MathJax-mhchem/ var className='atoc';"},"1-Chapter/10-用html标签直接引入Katex公式.html":{"url":"1-Chapter/10-用html标签直接引入Katex公式.html","title":"第一章 第10节：用html标签直接引入Katex公式","keywords":"","body":"第一章 第10节：用html标签直接引入Katex公式 直接引入和标签即可 \\(\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\\)，方程１ 这里之前加了1个br标签 这里之前加了1个br标签 爱因斯坦质能方程: \\(E =mc^2\\) ，方程是否在行中？ \\(\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\\)，方程１ 这里之前加了1个br标签 这里之前加了1个br标签 爱因斯坦质能方程: \\(E =mc^2\\) ，方程是否在行中？ var className='atoc';"},"1-Chapter/11-用html标签直接引入Mathjax公式.html":{"url":"1-Chapter/11-用html标签直接引入Mathjax公式.html","title":"第一章 第11节：用html标签直接引入Mathjax公式","keywords":"","body":"第一章 第11节：用html标签直接引入Mahtjax公式 直接引入和标签即可，注意math区块需要替换成2个$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); When $a \\ne 0$, there are two solutions to \\(ax^2 + bx + c = 0\\) and they are: {% math %}x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.{% endmath %} MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); When $a \\ne 0$, there are two solutions to \\(ax^2 + bx + c = 0\\) and they are: x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. var className='atoc';"},"2-Chapter/0-README.html":{"url":"2-Chapter/0-README.html","title":"第二章 PlantUML 语法指导手册","keywords":"","body":"第二章 PlantUML 语法指导手册 Markdown native diagrams with PlantUML 2018-07-31 / 9 MIN READ / ANOFF This post covers PlantUML basics and how it can be used in GitLab or GitHub projects as well as a seamless local development environment using Visual Studio Code. I have been wanting to write this post for months. Lately I have been using PlantUML extensively at work but also in my private projects. You can see it being used in my plantbuddy and techradar projects on GitHub. Using it in different places and for various purposes I came across a bunch of issues that I want to share in this post. PlantUML Basics &#x1F468;‍&#x1F3A8; For those that do not know PlantUML: It is an open source tool that allows you to define UML diagrams with plain text. There are different diagram types available being described with custom syntax but following a common scheme. This post will not go into the details of each of those diagram types because the PlantUML website does a pretty good job at describing sequence, component, activity and the other diagram types. A basic component diagram showing data flow can be built using the following markup: @startuml component actor client node app database db db -> app app -> client @enduml Reasons to love PlantUML &#x1F917; Versioning &#x1F4E6; A very important aspect for developing software and writing documentation is to keep it in sync. One part is to update documentation if the code itself is updated. Another important part is versioning - usually software is versioned using git or similar systems. By putting the documentation into the same repository as the code you make sure to always look at the correct state of documentation for a respective point in time. For that reason I love putting all my documentation either within the sourcecode as comments or as Markdown files next to the sourcecode. One thing I was always lacking with this approach is visualizing things. Putting PowerPoint/Keynote/Visio/Enterprise Architect.. files into a repository does make sure your diagrams are always versioned with the code - but they are not browsable in Web UIs. Come PlantUML and GitLab rendering to the rescue: GitLab allows you to inline PlantUML diagrams directly into your Markdown files and they will be rendered on the fly when viewing the files in the browser. One other benefit PlantUML has over the mentioned tools is that by defining your diagrams in plain text you make them diff-able in pull requests. Reviewers can always see what changes have been made and easily compare changes to the diagram with changes made inside the code. Syntax &#x1F41F; The basic syntax of PlantUML is very concise and builds a good foundation for the different diagram types. It is also well very smart in the way that it allows diagrams to be written with different flavors e.g. you can declare/instantiate all nodes at the top, but if you do not declare them they will be inferred automatically. Same goes for macros and definitions that allow you to compose larger diagrams or a common library for your team. I recently created a PlantUML Cheatsheet for a lot of useful tricks - it does however not cover the very basics of PlantUML syntax. You can browse the latest version or the LaTeX sourcecode on GitHub. Layouting &#x1F3D7; Compared with WYSIWYG editors PlantUML diagrams only define components and their relationship but not the actual layout of the diagram. Instead the diagram is inferred by a deterministic algorithm in the rendering process. This is beneficial when specifying the diagram because you only focus on the content - comparable to writing a LaTeX document. Sadly the layouting engine is not as good as you sometimes wish it to be and especially in component diagrams with 10+ nodes you might end up spending a lot of time enforcing specific layouts manually. For sequence and activity diagrams the automatic layouting works great even for very large diagrams. After you built a few diagrams and notice how easy it is to just move lines of code up and down and have changes in the code immediately reflect in your documentation you will love the automatic layouting. Share anywhere &#x1F4F1; If you want to freeze a diagram version and send it to someone outside your organization you can simply send them an insanely long url (e.g. http://www.plantuml.com/plantuml/png/5Son3G8n34RXtbFyb1GiG9MM6H25XGsnH9p8SGgslrpxzFILcHovse-yYw8QdlJl2v–N93rJ2Bg4EDlSBlG0pn6wDiu5NiDcAU6piJzTgKN5NNPu040) that encodes the entire diagram definition. You can also just embed this URL inside an HTML tag. If anyone ever needs to work with the image all you have to do is swap /plantuml/png to /plantuml/uml and you will see the definition of the diagram. This gives the entire PlantUML toolstack an extremely versatile way of passing information as well as viewable images. Local development &#x1F4BB; The fastest, platform agnostic and easiest way to start creating PlantUML diagrams is using their online editor (btw. you can easily host it on prem using the plantuml-server Docker image). This is fine for creating simple diagrams with a few nodes but larger diagrams require a lot of previewing which is annoying in the online editor. If you have any other local setups please let me know via Twitter Visual Studio Code In case you already use VS Code this is a no brainer to set up. Otherwise you might seriously want to consider using it for the purpose of editing PlantUML diagrams (in Markdown) only because it is a super smooth experience. All you need to do is to get the PlantUML extension to enable codes native Markdown preview feature to also parse inline diagrams. By default the plugin requires a local PlantUML process to be running and accepting the rendering requests. I recommend switching it to use a server for rendering; this could be the official plantuml.com server, an on premise instance or a locally running container. After installing the plugin go to the VS Code options (ctrl/⌘ + ,) and change the plantuml.render property. // PlantUMLServer: Render diagrams by server which is specified with \"plantuml.server\". It's much faster, but requires a server. // Local is the default configuration. \"plantuml.render\": \"PlantUMLServer\", // Plantuml server to generate UML diagrams on-the-fly. \"plantuml.server\": \"http://www.plantuml.com/plantuml\", If you ever go off the grid and still want to work remember to docker run -d -p 8080:8080 plantuml/plantuml-server:jetty while you still have an internet connection. The image is ~250MB to download. Afterwards set plantuml.server to http://localhost:8080/ and you’re set for an offline adventure. On my MacBook I sometimes experience a lot of CPU consumption from the running container - even when not actively rendering. Restarting the container helps &#x1F937;‍ Render to SVG/PDF This method only works if diagrams are defined explicitly in files and not inlined into Markdown. To write this blog post and build the Cheatsheet I played around with non-realtime ways of rendering PlantUML diagrams into images. You can use the Makefile and Shell script to convert an entire folder of PlantUML diagrams with .puml extension into .svg and .pdf files. The script essentially runs the diagram definition through a dockerized PlantUML process which outputs an .svg and then uses Inkscape to create a .pdf file for importing it into LaTeX documents for example. #!/bin/sh # converts all puml files to svg BASEDIR=$(dirname \"$0\") mkdir -p $BASEDIR/dist rm $BASEDIR/dist/* for FILE in $BASEDIR/*.puml; do echo Converting $FILE.. FILE_SVG=${FILE//puml/svg} FILE_PDF=${FILE//puml/pdf} cat $FILE | docker run --rm -i think/plantuml > $FILE_SVG docker run --rm -v $PWD:/diagrams productionwentdown/ubuntu-inkscape inkscape /diagrams/$FILE_SVG --export-area-page --without-gui --export-pdf=/diagrams/$FILE_PDF &> /dev/null done mv $BASEDIR/*.svg $BASEDIR/dist/ mv $BASEDIR/*.pdf $BASEDIR/dist/ echo Done GitLab integration This feature is currently only available with on-prem installations of GitLab, enabling it on gitlab.com is an open issue. See the GitHub integration for a workaround. Using PlantUML within GitLab is super fun. All you have to do is set up a render server to use and you can just commit Markdown files with inlined PlantUML diagrams and they will render for everyone visiting the GitLab web UI. What’s great is that this does not only works in Markdown files committed into a git repository but in all other fields within GitLab that render markdown - virtually everything. You can have small diagrams helping illustrate things in issues as well. GitHub integration There is no native PlantUML integration for GitHub and gitlab.com available. To maintain the advantages listed above it is obviously not a valid workaround to just render the files locally and commit them into git. Instead make use of the PlantUML proxy service as described in this stackoverflow discussion. The way this works is that instead of passing the PlantUML server the diagram content within the URL we define a remote URL where the content can be fetched from e.g. http://www.plantuml.com/plantuml/proxy?src=https://raw.github.com/plantuml/plantuml-server/master/src/main/webapp/resource/test2diagrams.txt. This URL can be embedded in an HTML tag or within Markdown image syntax ![](). To leverage this feature when using GitHub, simply point the remote URL to a raw link of the PlantUML diagram in your repository. You can see this method in action in the plantbuddy and techradar projects of my GitHub account. The following diagram shows what will happen when you open a Markdown page hosted on GitHub that contains such a link: This example shows that adding a ?cache=no might be a good idea because of GitHubs Camo caching strategy which will prevent your images from updating if you change the sourcecode. The downside of this approach is that it will always render the latest commmit in your repository even if you browse old versions. If browsing old versions is a strong requirement for you when using an integration with GitHub then you might need to build your own plugin/renderer or optimize the local development environment because after all the correct diagram version will always be with the sourcecode you checked out. To use the proxy service integration simply use: ![cached image](http://www.plantuml.com/plantuml/proxy?src=https://raw.github.com/plantuml/plantuml-server/master/src/main/webapp/resource/test2diagrams.txt) ![uncached image](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.github.com/plantuml/plantuml-server/master/src/main/webapp/resource/test2diagrams.txt) Summary There are two fundamental ways of keeping PlantUML diagrams inline into Markdown keep as individual .puml files Depending on your toolstack one of those should be your preferred option to work with diagrams in your repository. It is highly recommend to keep diagrams as close to the code as possible and not create artificial documentation repositories. This post covered how to write and render files locally in VS Code, using Docker containers and how to integrate into GitLab on prem as well as public GitHub and GitLab instances. There is a lot more to tell about PlantUML but I hope this article gave you enough infos to get started on whatever platform you are using. I recommend this PlantUML Cheatsheet which will help you to cover an even wider range of use cases. Tell me about your experiences with PlantUML or alternative integrations on Twitter &#x1F426; var className='atoc';"},"2-Chapter/1-时序图.html":{"url":"2-Chapter/1-时序图.html","title":"第二章 第1节：时序图","keywords":"","body":"第二章 第1节：时序图 简单示例 你可以用->来绘制参与者之间传递的消息， 而不必显式地声明参与者。你也可以使用 --> 绘制一个虚线箭头。另外，你还能用 和 ，这不影响绘图，但可以提高可读性。 注意：仅适用于时序图，对于其它示意图，规则是不同的。 @startuml skinparam defaultFontName \"Source Han Sans SC Light\" 用户 -> 认证中心: 登录操作 认证中心 -> 缓存: 存放(key=token+ip,value=token)token 用户 认证中心: 下次访问头部携带token认证 认证中心 用户: 信息 @enduml 声明参与者 关键字 participant 用于改变参与者的先后顺序。你也可以使用其它关键字来声明参与者： actor boundary control entity database collections @startuml actor Foo1 boundary Foo2 control Foo3 entity Foo4 database Foo5 collections Foo6 Foo1 -> Foo2 : To boundary Foo1 -> Foo3 : To control Foo1 -> Foo4 : To entity Foo1 -> Foo5 : To database Foo1 -> Foo6 : To collections @enduml 关键字 as 用于重命名参与者你可以使用RGB值或者颜色名修改 actor 或参与者的背景颜色。 @startuml actor Bob #red ' The only difference between actor 'and participant is the drawing participant Alice participant \"I have a really\\nlong name\" as L #99FF99 /' You can also declare: participant L as \"I have a really\\nlong name\" #99FF99 '/ Alice->Bob: Authentication Request Bob->Alice: Authentication Response Bob->L: Log transaction @enduml 您可以使用关键字 order自定义顺序来打印参与者。 @startuml participant Last order 30 participant Middle order 20 participant First order 10 @enduml 在参与者中使用非字母符号 你可以使用引号定义参与者，还可以用关键字 as 给参与者定义别名。 @startuml Alice -> \"Bob()\" : Hello \"Bob()\" -> \"This is very\\nlong\" as Long ' You can also declare: ' \"Bob()\" -> Long as \"This is very\\nlong\" Long --> \"Bob()\" : ok @enduml 给自己发消息 参与者可以给自己发信息，消息文字可以用\\n来换行。 @startuml Alice->Alice: This is a signal to self.\\nIt also demonstrates\\nmultiline \\ntext @enduml 修改箭头样式 修改箭头样式的方式有以下几种: 表示一条丢失的消息：末尾加 x 让箭头只有上半部分或者下半部分：将和>替换成\\或者 / 细箭头：将箭头标记写两次 (如 >> 或 //) 虚线箭头：用 -- 替代 - 箭头末尾加圈：->o 双向箭头： @startuml Bob ->x Alice Bob -> Alice Bob ->> Alice Bob -\\ Alice Bob \\\\- Alice Bob //-- Alice Bob ->o Alice Bob o\\\\-- Alice Bob Alice Bob o Alice @enduml 修改箭头颜色 你可以用以下记号修改箭头的颜色： @startuml Bob -[#red]> Alice : hello Alice -[#0000FF]->Bob : ok @enduml 对消息序列编号 关键字 autonumber 用于自动对消息编号。 @startuml autonumber Bob -> Alice : Authentication Request Bob 语句 autonumber //start// 用于指定编号的初始值，而 autonumber //start// //increment// 可以同时指定编号的初始值和每次增加的值。 @startuml autonumber Bob -> Alice : Authentication Request Bob Alice : Another authentication Request Bob Alice : Yet another authentication Request Bob 你可以在双引号内指定编号的格式。格式是由 Java 的DecimalFormat类实现的： (0 表示数字；# 也表示数字，但默认为0)。你也可以用 HTML 标签来制定格式。 @startuml autonumber \"[000]\" Bob -> Alice : Authentication Request Bob (##)\" Bob -> Alice : Another authentication Request Bob Message 0 \" Bob -> Alice : Yet another authentication Request Bob 你还可以用语句 autonumber stop 和 autonumber resume //increment// //format// 来表示暂停或继续使用自动编号。 @startuml autonumber 10 10 \"[000]\" Bob -> Alice : Authentication Request Bob Alice : dummy autonumber resume \"Message 0 \" Bob -> Alice : Yet another authentication Request Bob Alice : dummy autonumber resume 1 \"Message 0 \" Bob -> Alice : Yet another authentication Request Bob 页面标题,页眉,页脚 使用title关键词增加标题使用header关键词增加页眉使用footer关键词增加页脚 @startuml header Page Header footer Page %page% of %lastpage% title Example Title Alice -> Bob : message 1 Alice -> Bob : message 2 @enduml 分割示意图 关键字 newpage 用于把一张图分割成多张。在 newpage 之后添加文字，作为新的示意图的标题。这样就能很方便地在 Word 中将长图分几页打印。 @startuml Alice -> Bob : message 1 Alice -> Bob : message 2 newpage Alice -> Bob : message 3 Alice -> Bob : message 4 newpage A title for the\\nlast page Alice -> Bob : message 5 Alice -> Bob : message 6 @enduml 组合消息 我们可以通过以下关键词将组合消息： alt/else opt loop par break critical group, 后面紧跟着消息内容 可以在标头(header)添加需要显示的文字(group除外)。关键词 end 用来结束分组。注意，分组可以嵌套使用。 @startuml Alice -> Bob: Authentication Request alt successful case Bob -> Alice: Authentication Accepted else some kind of failure Bob -> Alice: Authentication Failure group My own label Alice -> Log : Log attack start loop 1000 times Alice -> Bob: DNS Attack end Alice -> Log : Log attack end end else Another type of failure Bob -> Alice: Please repeat end @enduml 给消息添加注释 我们可以通过在消息后面添加 note left 或者 note right 关键词来给消息添加注释。你也可以通过使用 end note 来添加多行注释。 @startuml Alice->Bob : hello note left: this is a first note Bob->Alice : ok note right: this is another note Bob->Bob : I am thinking note left a note can also be defined on several lines end note @enduml 其他的注释 可以使用note left of，note right of或note over在节点(participant)的相对位置放置注释。还可以通过修改背景色来高亮显示注释。以及使用关键字end note来添加多行注释。 @startuml participant Alice participant Bob note left of Alice #aqua This is displayed left of Alice. end note note right of Alice: This is displayed right of Alice. note over Alice: This is displayed over Alice. note over Alice, Bob #FFAAAA: This is displayed\\n over Bob and Alice. note over Bob, Alice This is yet another example of a long note. end note @enduml 改变备注框的形状 你可以使用 hnote 和 rnote 这两个关键字来修改备注框的形状。 @startuml caller -> server : conReq hnote over caller : idle caller Creole和HTML 可以使用creole格式。 @startuml participant Alice participant \"The **Famous** Bob\" as Bob Alice -> Bob : hello --there-- ... Some ~~long delay~~ ... Bob -> Alice : ok note left This is **bold** This is //italics// This is \"\"monospaced\"\" This is --stroked-- This is __underlined__ This is ~~waved~~ end note Alice -> Bob : A //well formatted// message note right of Alice This is displayed __left of__ Alice. end note note left of Bob This is displayed **left of Alice Bob**. end note note over Alice, Bob This is hosted by end note @enduml 分隔符 你可以通过使用 == 关键词来将你的图表分割多个步骤。 @startuml == Initialization == Alice -> Bob: Authentication Request Bob --> Alice: Authentication Response == Repetition == Alice -> Bob: Another authentication Request Alice 引用 你可以在图中通过使用ref over关键词来实现引用 @startuml participant Alice actor Bob ref over Alice, Bob : init Alice -> Bob : hello ref over Bob This can be on several lines end ref @enduml 延迟 你可以使用...来表示延迟，并且还可以给延迟添加注释。 @startuml Alice -> Bob: Authentication Request ... Bob --> Alice: Authentication Response ...5 minutes latter... Bob --> Alice: Bye ! @enduml 空间 你可以使用|||来增加空间。还可以使用数字指定增加的像素的数量。 @startuml Alice -> Bob: message 1 Bob --> Alice: ok ||| Alice -> Bob: message 2 Bob --> Alice: ok ||45|| Alice -> Bob: message 3 Bob --> Alice: ok @enduml 生命线的激活与撤销 关键字activate和deactivate用来表示参与者的生命活动。一旦参与者被激活，它的生命线就会显示出来。activate和deactivate适用于以上情形。destroy表示一个参与者的生命线的终结。 @startuml participant User User -> A: DoWork activate A A -> B: > activate B B -> C: DoWork activate C C --> B: WorkDone destroy C B --> A: RequestCreated deactivate B A -> User: Done deactivate A @enduml 还可以使用嵌套的生命线，并且运行给生命线添加颜色。 @startuml participant User User -> A: DoWork activate A #FFBBBB A -> A: Internal call activate A #DarkSalmon A -> B: > activate B B --> A: RequestCreated deactivate B deactivate A A -> User: Done deactivate A @enduml Return A new command return for generating a return message with optional text label. The point returned to is the point that cause the most recently activated life-line. The syntax is simply return label where label, if provided, can be any string acceptable on conventional messages. @startuml Bob -> Alice : hello activate Alice Alice -> Alice : some action return bye @enduml 创建参与者 你可以把关键字create放在第一次接收到消息之前，以强调本次消息实际上是在创建新的对象。 @startuml Bob -> Alice : hello create Other Alice -> Other : new create control String Alice -> String note right : You can also put notes! Alice --> Bob : ok @enduml Shortcut syntax for activation, deactivation, creation Immediately after specifying the target participant, the following syntax can be used: ++ Activate the target (optionally a #color may follow this) -- Deactivate the source ** Create an instance of the target !! Destroy an instance of the target @startuml alice -> bob ++ : hello bob -> bob ++ : self call bob -> bib ++ #005500 : hello bob -> george ** : create return done return rc bob -> george !! : delete return success @enduml 进入和发出消息 如果只想关注部分图示，你可以使用进入和发出箭头。使用方括号[和]表示图示的左、右两侧。 @startuml [-> A: DoWork activate A A -> A: Internal call activate A A ->] : > A 还可以使用下面的语法: @startuml [-> Bob [o-> Bob [o->o Bob [x-> Bob [] Bob ->o] Bob o->o] Bob ->x] Bob Anchors and Duration With teoz usage it is possible to add anchors to the diagram and use the anchors to specify duration time. @startuml !pragma teoz true {start} Alice -> Bob : start doing things during duration Bob -> Max : something Max -> Bob : something else {end} Bob -> Alice : finish {start} {end} : some time @enduml 构造类型和圈点 可以使用和>>给参与者添加构造类型。在构造类型中，你可以使用(X,color)格式的语法添加一个圆圈圈起来的字符。 @startuml participant \"Famous Bob\" as Bob > participant Alice > Bob->Alice: First message @enduml 默认使用 guillemet 字符来显示构造类型。 你可以使用外观参数 guillemet 来修改显示行为。 @startuml skinparam guillemet false participant \"Famous Bob\" as Bob > participant Alice > Bob->Alice: First message @enduml @startuml participant Bob > participant Alice > Bob->Alice: First message @enduml 更多标题信息 你可以在标题中使用creole格式。 @startuml title __Simple__ **communication** example Alice -> Bob: Authentication Request Bob -> Alice: Authentication Response @enduml 在标题描述中使用\\n表示换行。 @startuml title __Simple__ communication example\\non several lines Alice -> Bob: Authentication Request Bob -> Alice: Authentication Response @enduml 还可以使用关键字title和end title定义多行标题。 @startuml title Simple communication example on several lines and using html This is hosted by end title Alice -> Bob: Authentication Request Bob -> Alice: Authentication Response @enduml 包裹参与者 可以使用box和end box画一个盒子将参与者包裹起来。还可以在box关键字之后添加标题或者背景颜色。 @startuml box \"Internal Service\" #LightBlue participant Bob participant Alice end box participant Other Bob -> Alice : hello Alice -> Other : hello @enduml 移除脚注 使用hide footbox关键字移除脚注。 @startuml hide footbox title Footer removed Alice -> Bob: Authentication Request Bob --> Alice: Authentication Response @enduml 外观参数(skinparam) 用skinparam改变字体和颜色。可以在如下场景中使用： 在图示的定义中， 在引入的文件中， 在命令行或者ANT任务提供的配置文件中。 你也可以修改其他渲染元素，如以下示例： @startuml skinparam sequenceArrowThickness 2 skinparam roundcorner 20 skinparam maxmessagesize 60 skinparam sequenceParticipant underline actor User participant \"First Class\" as A participant \"Second Class\" as B participant \"Last Class\" as C User -> A: DoWork activate A A -> B: Create Request activate B B -> C: DoWork activate C C --> B: WorkDone destroy C B --> A: Request Created deactivate B A --> User: Done deactivate A @enduml @startuml skinparam backgroundColor #EEEBDC skinparam handwritten true skinparam sequence { ArrowColor DeepSkyBlue ActorBorderColor DeepSkyBlue LifeLineBorderColor blue LifeLineBackgroundColor #A9DCDF ParticipantBorderColor DeepSkyBlue ParticipantBackgroundColor DodgerBlue ParticipantFontName Impact ParticipantFontSize 17 ParticipantFontColor #A9DCDF ActorBackgroundColor aqua ActorFontColor DeepSkyBlue ActorFontSize 17 ActorFontName Aapex } actor User participant \"First Class\" as A participant \"Second Class\" as B participant \"Last Class\" as C User -> A: DoWork activate A A -> B: Create Request activate B B -> C: DoWork activate C C --> B: WorkDone destroy C B --> A: Request Created deactivate B A --> User: Done deactivate A @enduml 填充区设置 可以设定填充区的参数配置。 @startuml skinparam ParticipantPadding 20 skinparam BoxPadding 10 box \"Foo1\" participant Alice1 participant Alice2 end box box \"Foo2\" participant Bob1 participant Bob2 end box Alice1 -> Bob1 : hello Alice1 -> Out : out @enduml var className='atoc';"},"2-Chapter/2-用例图.html":{"url":"2-Chapter/2-用例图.html","title":"第二章 第2节：用例图","keywords":"","body":"第二章 第2节：用例图 Let's have few examples :Note that you can disable the shadowing using the skinparam shadowing false command. 用例 用例用圆括号括起来。也可以用关键字usecase来定义用例。 还可以用关键字as定义一个别名，这个别名可以在以后定义关系的时候使用。 @startuml (First usecase) (Another usecase) as (UC2) usecase UC3 usecase (Last\\nusecase) as UC4 @enduml 角色 角色用两个冒号包裹起来。也可以用actor关键字来定义角色。 还可以用关键字as来定义一个别名，这个别名可以在以后定义关系的时候使用。后面我们会看到角色的定义是可选的。 @startuml :First Actor: :Another\\nactor: as Men2 actor Men3 actor :Last actor: as Men4 @enduml 用例描述 如果想定义跨越多行的用例描述，可以用双引号将其裹起来。还可以使用这些分隔符：--``..``==``__。 并且还可以在分隔符中间放置标题。 @startuml usecase UC1 as \"You can use several lines to define your usecase. You can also use separators. -- Several separators are possible. == And you can add titles: ..Conclusion.. This allows large description.\" @enduml Use package You can use packages to group actors or use cases. @startuml left to right direction actor \"Food Critic\" as fc package Restaurant { usecase \"Eat Food\" as UC1 usecase \"Pay for Food\" as UC2 usecase \"Drink\" as UC3 } fc --> UC1 fc --> UC2 fc --> UC3 @enduml You can use rectangle to change the display of the package. @startuml left to right direction actor \"Food Critic\" as fc rectangle Restaurant { usecase \"Eat Food\" as UC1 usecase \"Pay for Food\" as UC2 usecase \"Drink\" as UC3 } fc --> UC1 fc --> UC2 fc --> UC3 @enduml 基础示例 用箭头-->连接角色和用例。横杠-越多，箭头越长。 通过在箭头定义的后面加一个冒号及文字的方式来添加标签。在这个例子中，User并没有定义，而是直接拿来当做一个角色使用。 @startuml User -> (Start) User --> (Use the application) : A small label :Main Admin: ---> (Use the application) : This is\\nyet another\\nlabel @enduml 继承 如果一个角色或者用例继承于另一个，那么可以用符号表示。 @startuml :Main Admin: as Admin (Use the application) as (Use) User 使用注释 可以用note left of , note right of , note top of , note bottom of等关键字给一个对象添加注释。注释还可以通过note关键字来定义，然后用..连接其他对象。 @startuml :Main Admin: as Admin (Use the application) as (Use) User -> (Start) User --> (Use) Admin ---> (Use) note right of Admin : This is an example. note right of (Use) A note can also be on several lines end note note \"This note is connected\\nto several objects.\" as N2 (Start) .. N2 N2 .. (Use) @enduml 构造类型 用 和 >> 来定义角色或者用例的构造类型。 @startuml User > :Main Database: as MySql > (Start) > (Use the application) as (Use) > User -> (Start) User --> (Use) MySql --> (Use) @enduml 改变箭头方向 默认连接是竖直方向的，用--表示，可以用一个横杠或点来表示水平连接。 @startuml :user: --> (Use case 1) :user: -> (Use case 2) @enduml 也可以通过翻转箭头来改变方向。 @startuml (Use case 1) 还可以通过给箭头添加left, right, up或down等关键字来改变方向。 @startuml :user: -left-> (dummyLeft) :user: -right-> (dummyRight) :user: -up-> (dummyUp) :user: -down-> (dummyDown) @enduml 这些方向关键字也可以只是用首字母或者前两个字母的缩写来代替。但是请注意，这样的缩写不要乱用，Graphviz不喜欢这样。 分割图示 用newpage关键字将图示分解为多个页面。 @startuml :actor1: --> (Usecase1) newpage :actor2: --> (Usecase2) @enduml 从左向右方向 默认从上往下构建图示。 @startuml 'default top to bottom direction user1 --> (Usecase 1) user2 --> (Usecase 2) @enduml 你可以用left to right direction命令改变图示方向。 @startuml left to right direction user1 --> (Usecase 1) user2 --> (Usecase 2) @enduml 显示参数 用skinparam改变字体和颜色。可以在如下场景中使用： 在图示的定义中， 在引入的文件中， 在命令行或者ANT任务提供的配置文件中。 你也可以给构造的角色和用例指定特殊颜色和字体。 @startuml skinparam handwritten true skinparam usecase { BackgroundColor DarkSeaGreen BorderColor DarkSlateGray BackgroundColor> YellowGreen BorderColor> YellowGreen ArrowColor Olive ActorBorderColor black ActorFontName Courier ActorBackgroundColor> Gold } User > :Main Database: as MySql > (Start) > (Use the application) as (Use) > User -> (Start) User --> (Use) MySql --> (Use) @enduml 一个完整的例子 @startuml left to right direction skinparam packageStyle rectangle actor customer actor clerk rectangle checkout { customer -- (checkout) (checkout) .> (payment) : include (help) .> (checkout) : extends (checkout) -- clerk } @enduml var className='atoc';"},"2-Chapter/3-类图.html":{"url":"2-Chapter/3-类图.html","title":"第二章 第3节：类图","keywords":"","body":"第二章 第3节：类图 类之间的关系 类之间的关系通过下面的符号定义 : Type Symbol Drawing Extension（扩展） \\color{fuchsia}{\\verb+ Composition（组合） \\color{fuchsia}{\\verb+*--+} Aggregation（聚合） \\color{fuchsia}{\\verb+o--+} 使用.. 来代替 -- 可以得到点 线.在这些规则下，也可以绘制下列图形 @startuml Class01 @startuml Class11 Class14 Class15 ..> Class16 Class17 ..|> Class18 Class19 @startuml Class21 #-- Class22 Class23 x-- Class24 Class25 }-- Class26 Class27 +-- Class28 Class29 ^-- Class30 @enduml 关系上的标识 在关系之间使用标签来说明时, 使用 :后接 标签文字。对元素的说明，你可以在每一边使用 \"\" 来说明. @startuml Class01 \"1\" *-- \"many\" Class02 : contains Class03 o-- Class04 : aggregation Class05 --> \"1\" Class06 @enduml 在标签的开始或结束位置添加 或 >以表明是哪个对象作用到哪个对象上。 @startuml class Car Driver - Car : drives > Car *- Wheel : have 4 > Car -- Person : 添加方法 为了声明字段(对象属性）或者方法，你可以使用 后接字段名或方法名。系统检查是否有括号来判断是方法还是字段。 @startuml Object 也可以使用{} 把字段或者方法括起来注意，这种语法对于类型/名字的顺序是非常灵活的。 @startuml class Dummy { String data void methods() } class Flight { flightNumber : Integer departureTime : Date } @enduml 你可以（显式地）使用 {field} 和 {method} 修饰符来覆盖解析器的对于字段和方法的默认行为 @startuml class Dummy { {field} A field (despite parentheses) {method} Some method } @enduml 定义可访问性 一旦你定义了域或者方法，你可以定义 相应条目的可访问性质。 Character Icon for field Icon for method Visibility - private # protected ~ package private + public @startuml class Dummy { -field1 #field2 ~method1() +method2() } @enduml 你可以采用以下命令停用这些特性 skinparam classAttributeIconSize 0 ： @startuml skinparam classAttributeIconSize 0 class Dummy { -field1 #field2 ~method1() +method2() } @enduml 抽象与静态 通过修饰符{static}或者{abstract}，可以定义静态或者抽象的方法或者属性。这些修饰符可以写在行的开始或者结束。也可以使用{classifier}这个修饰符来代替{static}. @startuml class Dummy { {static} String id {abstract} void methods() } @enduml 高级类体 PlantUML默认自动将方法和属性重新分组，你可以自己定义分隔符来重排方法和属性，下面的分隔符都是可用的：--``..``==``__.还可以在分隔符中添加标题： @startuml class Foo1 { You can use several lines .. as you want and group == things together. __ You can have as many groups as you want -- End of class } class User { .. Simple Getter .. + getName() + getAddress() .. Some setter .. + setName() __ private data __ int age -- encrypted -- String password } @enduml 备注和模板 模板通过类关键字(\"\"和\">>\")来定义你可以使用note left of , note right of , note top of , note bottom of这些关键字来添加备注。你还可以在类的声明末尾使用note left, note right,note top, note bottom来添加备注。此外，单独用note这个关键字也是可以的，使用 .. 符号可以作出一条连接它与其它对象的虚线。 @startuml class Object > Object 更多注释 可以在注释中使用部分html标签： , , or or to change font size or : the file must be accessible by the filesystem 你也可以在注释中展示多行。你也可以在定义的class之后直接使用 note left, note right, note top, note bottom 来定义注释。 @startuml class Foo note left: On last defined class note top of Object In java, every class extends this one. end note note as N1 This note is also on several words lines And this is hosted by end note @enduml 链接的注释 在定义链接之后，你可以用 note on link 给链接添加注释如果想要改变注释相对于标签的位置，你也可以用 note left on link， note right on link， note bottom on link。（对应位置分别在label的左边，右边，下边） @startuml class Dummy Dummy --> Foo : A link note on link #red: note that is red Dummy --> Foo2 : Another link note right on link #blue this is my note on right link and in blue end note @enduml 抽象类和接口 用关键字abstract或abstract class来定义抽象类。抽象类用斜体显示。 也可以使用interface, annotation 和 enum关键字。 @startuml abstract class AbstractList abstract AbstractCollection interface List interface Collection List 使用非字母字符 如果你想在类（或者枚举）的显示中使用非字母符号，你可以： 在类的定义中使用 as 关键字 在类名旁边加上 \"\" @startuml class \"This is my class\" as class1 class class2 as \"It works this way too\" class2 *-- \"foo/dummy\" : use @enduml 隐藏属性、函数等 通过使用命令“hide/show”，你可以用参数表示类的显示方式。基础命令是: hide empty members. 这个命令会隐藏空白的方法和属性。除 empty members 外，你可以用: empty fields 或者 empty attributes 空属性, empty methods 空函数， fields 或 attributes 隐藏字段或属性，即使是被定义了 methods 隐藏方法，即使是被定义了 members 隐藏字段 和 方法，即使是被定义了 circle 类名前带圈的， stereotype 原型。 同样可以使用 hide 或 show 关键词，对以下内容进行设置： class 所有类， interface 所有接口， enum 所有枚举， <> 实现 foo1 的类， 一个既定的类名。 你可以使用 show/hide 命令来定义相关规则和例外。 @startuml class Dummy1 { +myMethods() } class Dummy2 { +hiddenMethod() } class Dummy3 > { String name } hide members hide > circle show Dummy1 methods show > fields @enduml 隐藏类 你也可以使用 show/hide 命令来隐藏类如果你定义了一个大的!included 文件，且想在文件包含之后隐藏部分类，该功能会很有帮助。 @startuml class Foo1 class Foo2 Foo2 *-- Foo1 hide Foo2 @enduml 泛型（generics） 你可以用 和 > 来定义类的泛型。 @startuml class Foo { int size() } Foo *- Element @enduml It is possible to disable this drawing using skinparam genericDisplay old command. 指定标记（Spot） 通常标记字符 (C, I, E or A) 用于标记 类(classes), 接口（interface）, 枚举（enum）和 抽象类（abstract classes）.但是当你想定义原型时，可以增加对应的单个字符及颜色，来定义自己的标记（spot），就像下面一样： @startuml class System > class Date > @enduml 包 你可以通过关键词 package 声明包，同时可选的来声明对应的背景色（通过使用html色彩代码或名称）。注意：包可以被定义为嵌套。 @startuml package \"Classic Collections\" #DDDDDD { Object 包样式 包可以定义不同的样式。你可以通过以下的命令来设置默认样式 : skinparam packageStyle,或者对包使用对应的模板: @startuml scale 750 width package foo1 > { class Class1 } package foo2 > { class Class2 } package foo3 > { class Class3 } package foo4 > { class Class4 } package foo5 > { class Class5 } package foo6 > { class Class6 } @enduml 你也可以参考下面的示例来定义包之间的连线: @startuml skinparam packageStyle rectangle package foo1.foo2 { } package foo1.foo2.foo3 { class Object } foo1.foo2 +-- foo1.foo2.foo3 @enduml 命名空间（Namespaces） 在使用包（package）时（区别于命名空间），类名是类的唯一标识。 也就意味着，在不同的包（package）中的类，不能使用相同的类名。在那种情况下（译注：同名、不同全限定名类），你应该使用命名空间来取而代之。你可以从其他命名空间，使用全限定名来引用类， 默认命名空间（译注：无名的命名空间）下的类，以一个“.\"开头（的类名）来引用（译注：示例中的BaseClass).注意：你不用显示地创建命名空间：一个使用全限定名的类会自动被放置到对应的命名空间。 @startuml class BaseClass namespace net.dummy #DDDDDD { .BaseClass 自动创建命名空间 使用命令 set namespaceSeparator ??? 你可以自定义命名空间分隔符（为 “.” 以外的字符）. @startuml set namespaceSeparator :: class X1::X2::foo { some info } @enduml 禁止自动创建包则可以使用 set namespaceSeparator none. @startuml set namespaceSeparator none class X1.X2.foo { some info } @enduml 棒棒糖 接口 需要定义棒棒糖样式的接口时可以遵循以下语法: bar ()- foo bar ()-- foo foo -() bar @startuml class foo bar ()- foo @enduml 改变箭头方向 类之间默认采用两个破折号 -- 显示出垂直 方向的线. 要得到水平方向的可以像这样使用单破折号 (或者点): @startuml Room o- Student Room *-- Chair @enduml 你也可以通过改变倒置链接来改变方向 @startuml Student -o Room Chair --* Room @enduml 也可通过在箭头内部使用关键字， 例如left, right, up 或者 down，来改变方向 @startuml foo -left-> dummyLeft foo -right-> dummyRight foo -up-> dummyUp foo -down-> dummyDown @enduml You can shorten the arrow by using only the first character of the direction (for example, -d- instead of -down-) or the two first characters (-do-).Please note that you should not abuse this functionality : Graphviz gives usually good results without tweaking. “关系”类 你可以在定义了两个类之间的关系后定义一个 关系类 association class 例如: @startuml class Student { Name } Student \"0..*\" - \"1..*\" Course (Student, Course) .. Enrollment class Enrollment { drop() cancel() } @enduml 也可以用另一种方式: @startuml class Student { Name } Student \"0..*\" -- \"1..*\" Course (Student, Course) . Enrollment class Enrollment { drop() cancel() } @enduml 皮肤参数 用skinparam改变字体和颜色。可以在如下场景中使用： 在图示的定义中， 在引入的文件中， 在命令行或者ANT任务提供的配置文件中。 @startuml skinparam class { BackgroundColor PaleGreen ArrowColor SeaGreen BorderColor SpringGreen } skinparam stereotypeCBackgroundColor YellowGreen Class01 \"1\" *-- \"many\" Class02 : contains Class03 o-- Class04 : aggregation @enduml Skinned Stereotypes You can define specific color and fonts for stereotyped classes. @startuml skinparam class { BackgroundColor PaleGreen ArrowColor SeaGreen BorderColor SpringGreen BackgroundColor> Wheat BorderColor> Tomato } skinparam stereotypeCBackgroundColor YellowGreen skinparam stereotypeCBackgroundColor> DimGray Class01 > Class03 > Class01 \"1\" *-- \"many\" Class02 : contains Class03 o-- Class04 : aggregation @enduml Color gradient It's possible to declare individual color for classes or note using the # notation.You can use either standard color name or RGB code.You can also use color gradient in background, with the following syntax: two colors names separated either by: |, /, \\, or - depending the direction of the gradient.For example, you could have: @startuml skinparam backgroundcolor AntiqueWhite/Gold skinparam classBackgroundColor Wheat|CornflowerBlue class Foo #red-green note left of Foo #blue\\9932CC this is my note on this class end note package example #GreenYellow/LightGoldenRodYellow { class Dummy } @enduml 辅助布局 有时候，默认布局并不完美...你可以使用 together 关键词将某些类进行分组： 布局引擎会尝试将它们捆绑在一起（如同在一个包(package)内)你也可以使用建立 隐藏 链接的方式来强制布局 @startuml class Bar1 class Bar2 together { class Together1 class Together2 class Together3 } Together1 - Together2 Together2 - Together3 Together2 -[hidden]--> Bar1 Bar1 -[hidden]> Bar2 @enduml 拆分大文件 有些情况下，会有一些很大的图片文件。可以用 page (hpages)x(vpages) 这个命令把生成的图片文件拆分成若干个文件。hpages 用来表示水平方向页面数， and vpages 用来表示垂直方面页面数。你也可以使用特定的皮肤设定来给分页添加边框（见例子） @startuml ' Split into 4 pages page 2x2 skinparam pageMargin 10 skinparam pageExternalColor gray skinparam pageBorderColor black class BaseClass namespace net.dummy #DDDDDD { .BaseClass Extends and implements It is also possible to use extends and implements keywords. @startuml class ArrayList implements List class ArrayList extends AbstractList @enduml var className='atoc';"},"2-Chapter/4-活动图.html":{"url":"2-Chapter/4-活动图.html","title":"第二章 第4节：活动图","keywords":"","body":"第二章 第4节：活动图 当前活动图(activity diagram)的语法有诸多限制和缺点，比如代码难以维护。 所以从V7947开始提出一种全新的、更好的语法格式和软件实现供用户使用(beta版)。 就像序列图一样，新的软件实现的另一个优点是它不再依赖于Graphviz。 新的语法将会替换旧的语法。然而考虑到兼容性，旧的语法仍被能够使用以确保向前兼容。 但是我们鼓励用户使用新的语法格式。 简单活动图 活动标签(activity label)以冒号开始，以分号结束。文本格式支持creole wiki语法。活动默认安装它们定义的顺序就行连接。 @startuml :Hello world; :This is on defined on several **lines**; @enduml 开始/结束 你可以使用关键字start和stop表示图示的开始和结束。 @startuml start :Hello world; :This is on defined on several **lines**; stop @enduml 也可以使用 end 关键字。 @startuml start :Hello world; :This is on defined on several **lines**; end @enduml 条件语句 在图示中可以使用关键字if，then和else设置分支测试。标注文字则放在括号中。 @startuml start if (Graphviz installed?) then (yes) :process all\\ndiagrams; else (no) :process only __sequence__ and __activity__ diagrams; endif stop @enduml 也可以使用关键字elseif设置多个分支测试。 @startuml start if (condition A) then (yes) :Text 1; elseif (condition B) then (yes) :Text 2; stop elseif (condition C) then (yes) :Text 3; elseif (condition D) then (yes) :Text 4; else (nothing) :Text else; endif stop @enduml 重复循环 你可以使用关键字repeat和repeatwhile进行重复循环。 @startuml start repeat :read data; :generate diagrams; repeat while (more data?) stop @enduml It is also possible to use a full action as repeat target and insert an action in the return path using the backward keyword. @startuml start repeat :foo as starting label; :read data; :generate diagrams; backward:This is backward; repeat while (more data?) stop @enduml while循环 可以使用关键字while和end while进行while循环。 @startuml start while (data available?) :read data; :generate diagrams; endwhile stop @enduml 还可以在关键字endwhile后添加标注，还有一种方式是使用关键字is。 @startuml while (check filesize ?) is (not empty) :read file; endwhile (empty) :close file; @enduml 并行处理 你可以使用关键字fork，fork again和end fork表示并行处理。 @startuml start if (multiprocessor?) then (yes) fork :Treatment 1; fork again :Treatment 2; end fork else (monoproc) :Treatment 1; :Treatment 2; endif @enduml 注释 文本格式支持creole wiki语法。A note can be floating, using floating keyword. @startuml start :foo1; floating note left: This is a note :foo2; note right This note is on several //lines// and can contain HTML ==== * Calling the method \"\"foo()\"\" is prohibited end note stop @enduml 颜色 你可以为活动(activity)指定一种颜色。 @startuml start :starting progress; #HotPink:reading configuration files These files should edited at this point!; #AAAAAA:ending of the process; @enduml 箭头 使用->标记，你可以给箭头添加文字或者修改箭头颜色。同时，你也可以选择点状 (dotted)，条状(dashed)，加粗或者是隐式箭头 @startuml :foo1; -> You can put text on arrows; if (test) then -[#blue]-> :foo2; -[#green,dashed]-> The text can also be on several lines and **very** long...; :foo3; else -[#black,dotted]-> :foo4; endif -[#gray,bold]-> :foo5; @enduml 连接器(Connector) 你可以使用括号定义连接器。 @startuml start :Some activity; (A) detach (A) :Other activity; @enduml 组合(grouping) 通过定义分区(partition)，你可以把多个活动组合(group)在一起。 @startuml start partition Initialization { :read config file; :init internal variable; } partition Running { :wait for user interaction; :print information; } stop @enduml 泳道(Swimlanes) 你可以使用管道符|来定义泳道。还可以改变泳道的颜色。 @startuml |Swimlane1| start :foo1; |#AntiqueWhite|Swimlane2| :foo2; :foo3; |Swimlane1| :foo4; |Swimlane2| :foo5; stop @enduml 分离(detach) 可以使用关键字detach移除箭头。 @startuml :start; fork :foo1; :foo2; fork again :foo3; detach endfork if (foo4) then :foo5; detach endif :foo6; detach :foo7; stop @enduml 特殊领域语言(SDL) 通过修改活动标签最后的分号分隔符(;)，可以为活动设置不同的形状。 | > / ] } @startuml :Ready; :next(o)| :Receiving; split :nak(i) split again :ack(i) split again :err(i) split again :foo/ split again :i > 5} stop end split :finish; @enduml 一个完整的例子 @startuml start :ClickServlet.handleRequest(); :new page; if (Page.onSecurityCheck) then (true) :Page.onInit(); if (isForward?) then (no) :Process controls; if (continue processing?) then (no) stop endif if (isPost?) then (yes) :Page.onPost(); else (no) :Page.onGet(); endif :Page.onRender(); endif else (false) endif if (do redirect?) then (yes) :redirect process; else if (do forward?) then (yes) :Forward request; else (no) :Render page template; endif endif stop @enduml var className='atoc';"},"2-Chapter/5-组件图.html":{"url":"2-Chapter/5-组件图.html","title":"第二章 第5节：组件图","keywords":"","body":"第二章 第5节：组件图 我们来看几个例子 : 组件 组件必须用中括号括起来。 还可以使用关键字component定义一个组件。 并且可以用关键字as给组件定义一个别名。 这个别名可以在稍后定义关系的时候使用。 @startuml [First component] [Another component] as Comp2 component Comp3 component [Last\\ncomponent] as Comp4 @enduml 接口 接口可以使用()来定义(因为这个看起来像个圆)。 还可以使用关键字interface关键字来定义接口。 并且还可以使用关键字as定义一个别名。 这个别名可以在稍后定义关系的时候使用。 我们稍后可以看到，接口的定义是可选的。 @startuml () \"First Interface\" () \"Another interface\" as Interf2 interface Interf3 interface \"Last\\ninterface\" as Interf4 @enduml 基础的示例 元素之间可以使用虚线(..)、直线(--)、箭头(-->)进行连接。 @startuml DataAccess - [First Component] [First Component] ..> HTTP : use @enduml 使用注释 你可以使用 note left of , note right of , note top of , note bottom of 等关键字定义相对于对象位置的注释。 也可以使用关键字note单独定义注释，然后使用虚线(..)将其连接到其他对象。 @startuml interface \"Data Access\" as DA DA - [First Component] [First Component] ..> HTTP : use note left of HTTP : Web Service only note right of [First Component] A note can also be on several lines end note @enduml 组合组件 你可以使用多个关键字将组件和接口组合在一起。 package node folder frame cloud database @startuml package \"Some Group\" { HTTP - [First Component] [Another Component] } node \"Other Groups\" { FTP - [Second Component] [First Component] --> FTP } cloud { [Example 1] } database \"MySql\" { folder \"This is my folder\" { [Folder 3] } frame \"Foo\" { [Frame 4] } } [Another Component] --> [Example 1] [Example 1] --> [Folder 3] [Folder 3] --> [Frame 4] @enduml 改变箭头方向 默认情况下，对象之间用--连接，并且连接是竖直的。不过可以使用一个横线或者点设置水平方向的连接，就行这样： @startuml [Component] --> Interface1 [Component] -> Interface2 @enduml 也可以使用反向连接： @startuml Interface1 还可以使用关键字left, right, up or down改变箭头方向。 @startuml [Component] -left-> left [Component] -right-> right [Component] -up-> up [Component] -down-> down @enduml 允许使用方向单词的首字母或者前两个字母表示方向(例如-d-, -do-, -down-都是等价的)。 请不要乱用这些功能：Graphviz(PlantUML的后端引擎)不喜欢这个样子。 使用UML2标记符 命令skinparam componentStyle uml2 可以切换到UML2标记符。 @startuml skinparam componentStyle uml2 interface \"Data Access\" as DA DA - [First Component] [First Component] ..> HTTP : use @enduml 长描述 可以用方括号\"[ ]\"在连线上添加描述。 @startuml component comp1 [ This component has a long comment on several lines ] @enduml 不同的颜色表示 你可以在声明一个组件时加上颜色的声明。 @startuml component [Web Server] #Yellow @enduml 在定型组件中使用精灵图 你可以在定型组件中使用精灵图（sprite）。 @startuml sprite $businessProcess [16x16/16] { FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFF0FFFFF FFFFFFFFFF00FFFF FF00000000000FFF FF000000000000FF FF00000000000FFF FFFFFFFFFF00FFFF FFFFFFFFFF0FFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF } rectangle \" End to End\\nbusiness process\" > { rectangle \"inner process 1\" > as src rectangle \"inner process 2\" > as tgt src -> tgt } @enduml 显示参数 用skinparam改变字体和颜色。可以在如下场景中使用： 在图示的定义中， 在引入的文件中， 在命令行或者ANT任务提供的配置文件中。 可以为构造类型和接口定义特殊的颜色和字体。 @startuml skinparam interface { backgroundColor RosyBrown borderColor orange } skinparam component { FontSize 13 BackgroundColor> Red BorderColor> #FF6655 FontName Courier BorderColor black BackgroundColor gold ArrowFontName Impact ArrowColor #FF6655 ArrowFontColor #777777 } () \"Data Access\" as DA DA - [First Component] [First Component] ..> () HTTP : use HTTP - [Web Server] > @enduml @startuml [AA] > [BB] > [CC] > node node1 node node2 > database Production skinparam component { backgroundColor> DarkKhaki backgroundColor> Green } skinparam node { borderColor Green backgroundColor Yellow backgroundColor> Magenta } skinparam databaseBackgroundColor Aqua @enduml var className='atoc';"},"2-Chapter/6-状态图.html":{"url":"2-Chapter/6-状态图.html","title":"第二章 第6节：状态图","keywords":"","body":"第二章 第6节：状态图 简单状态 使用([*])开始和结束状态图。 使用-->添加箭头。 @startuml [*] --> State1 State1 --> [*] State1 : this is a string State1 : this is another string State1 -> State2 State2 --> [*] @enduml Change state rendering You can use hide empty description to render state as simple box. @startuml hide empty description [*] --> State1 State1 --> [*] State1 : this is a string State1 : this is another string State1 -> State2 State2 --> [*] @enduml 合成状态 一个状态也可能是合成的，必须使用关键字state和花括号来定义合成状态。 @startuml scale 350 width [*] --> NotShooting state NotShooting { [*] --> Idle Idle --> Configuring : EvConfig Configuring --> Idle : EvConfig } state Configuring { [*] --> NewValueSelection NewValueSelection --> NewValuePreview : EvNewValue NewValuePreview --> NewValueSelection : EvNewValueRejected NewValuePreview --> NewValueSelection : EvNewValueSaved state NewValuePreview { State1 -> State2 } } @enduml 长名字 也可以使用关键字state定义长名字状态。 @startuml scale 600 width [*] -> State1 State1 --> State2 : Succeeded State1 --> [*] : Aborted State2 --> State3 : Succeeded State2 --> [*] : Aborted state State3 { state \"Accumulate Enough Data\\nLong State Name\" as long1 long1 : Just a test [*] --> long1 long1 --> long1 : New Data long1 --> ProcessData : Enough Data } State3 --> State3 : Failed State3 --> [*] : Succeeded / Save Result State3 --> [*] : Aborted @enduml History You can use [H] for the history and [H*] for the deep history of a substate @startuml [*] -> State1 State1 --> State2 : Succeeded State1 --> [*] : Aborted State2 --> State3 : Succeeded State2 --> [*] : Aborted state State3 { state \"Accumulate Enough Data\" as long1 long1 : Just a test [*] --> long1 long1 --> long1 : New Data long1 --> ProcessData : Enough Data State2 --> [H]: Resume } State3 --> State2 : Pause 'State2 --> State3[H*]: DeepResume State3 --> State3 : Failed State3 --> [*] : Succeeded / Save Result State3 --> [*] : Aborted @enduml Fork You can also fork and join using the <> and <> stereotypes. @startuml state fork_state > [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state > State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] @enduml 并发状态 用-- or ||作为分隔符来合成并发状态。 @startuml [*] --> Active state Active { [*] -> NumLockOff NumLockOff --> NumLockOn : EvNumLockPressed NumLockOn --> NumLockOff : EvNumLockPressed -- [*] -> CapsLockOff CapsLockOff --> CapsLockOn : EvCapsLockPressed CapsLockOn --> CapsLockOff : EvCapsLockPressed -- [*] -> ScrollLockOff ScrollLockOff --> ScrollLockOn : EvCapsLockPressed ScrollLockOn --> ScrollLockOff : EvCapsLockPressed } @enduml Conditional The stereotype <> can be used to use conditional state. @startuml state \"Req(Id)\" as ReqId > state \"Minor(Id)\" as MinorId state \"Major(Id)\" as MajorId state c > Idle --> ReqId ReqId --> c c --> MinorId : [Id MajorId : [Id > 10] @enduml 箭头方向 使用->定义水平箭头，也可以使用下列格式强制设置箭头方向： -down-> (default arrow) -right-> or -> -left-> -up-> @startuml [*] -up-> First First -right-> Second Second --> Third Third -left-> Last @enduml 可以用首字母缩写或者开始的两个字母定义方向(如, -d-，-down-和-do-是完全等价的)。 请不要滥用这些功能，Graphviz不喜欢这样。 注释 可以用 note left of, note right of, note top of, note bottom of 关键字来定义注释。 还可以定义多行注释。 @startuml [*] --> Active Active --> Inactive note left of Active : this is a short\\nnote note right of Inactive A note can also be defined on several lines end note @enduml 以及浮动注释。 @startuml state foo note \"This is a floating note\" as N1 @enduml 更多注释 可以在合成状态中放置注释。 @startuml [*] --> NotShooting state \"Not Shooting State\" as NotShooting { state \"Idle mode\" as Idle state \"Configuring mode\" as Configuring [*] --> Idle Idle --> Configuring : EvConfig Configuring --> Idle : EvConfig } note right of NotShooting : This is a note on a composite state @enduml 显示参数 用skinparam改变字体和颜色。可以在如下场景中使用： 在图示的定义中， 在引入的文件中， 在命令行或者ANT任务提供的配置文件中。 还可以为状态的构造类型指定特殊的字体和颜色。 @startuml skinparam backgroundColor LightYellow skinparam state { StartColor MediumBlue EndColor Red BackgroundColor Peru BackgroundColor> Olive BorderColor Gray FontName Impact } [*] --> NotShooting state \"Not Shooting State\" as NotShooting { state \"Idle mode\" as Idle > state \"Configuring mode\" as Configuring [*] --> Idle Idle --> Configuring : EvConfig Configuring --> Idle : EvConfig } NotShooting --> [*] @enduml var className='atoc';"},"2-Chapter/7-对象图.html":{"url":"2-Chapter/7-对象图.html","title":"第二章 第7节：对象图","keywords":"","body":"第二章 第7节：对象图 对象的定义 使用关键字object定义实例。 @startuml object firstObject object \"My Second Object\" as o2 @enduml 对象之间的关系 对象之间的关系通过下面的符号定义 : Type Symbol Drawing Extension（扩展） \\color{fuchsia}{\\verb+ Composition（组合） \\color{fuchsia}{\\verb+*--+} Aggregation（聚合） \\color{fuchsia}{\\verb+o--+} 使用.. 来代替 -- 可以得到点 线. 知道了这些规则，就可以画下面的图： 可以用冒号给关系添加标签，标签内容紧跟在冒号之后。 用双引号在关系的两边添加基数。 @startuml object Object01 object Object02 object Object03 object Object04 object Object05 object Object06 object Object07 object Object08 Object01 添加属性 用冒号加属性名的形式声明属性。 @startuml object user user : name = \"Dummy\" user : id = 123 @enduml 也可以用大括号批量声明属性。 @startuml object user { name = \"Dummy\" id = 123 } @enduml 类图中的通用特性 可见性 定义注释 使用包 美化输出内容 var className='atoc';"},"2-Chapter/8-部署图.html":{"url":"2-Chapter/8-部署图.html","title":"第二章 第8节：部署图","keywords":"","body":"第二章 第8节：部署图 声明元素 @startuml actor actor agent agent artifact artifact boundary boundary card card cloud cloud component component control control database database entity entity file file folder folder frame frame interface interface node node package package queue queue stack stack rectangle rectangle storage storage usecase usecase @enduml 可选的，您可以使用方括号 [] 放置长描述文本。 @startuml folder folder [ 这是个 文件夹 ---- 您可以使用 ==== 不同类型 .... 的分隔符 ] node node [ 这是个 结点 ---- 您可以使用 ==== 不同类型 .... 的分隔符 ] database database [ 这是个 数据库 ---- 您可以使用 ==== 不同类型 .... 的分隔符 ] usecase usecase [ 这是个 用例 ---- 您可以使用 ==== 不同类型 .... 的分隔符 ] @enduml 链接 您可以在元素之间创建简单链接: @startuml node node1 node node2 node node3 node node4 node node5 node1 -- node2 node1 .. node3 node1 ~~ node4 node1 == node5 @enduml 您可以在元素之间创建简单链接: @startuml node node1 node node2 node node3 node node4 node node5 node1 -- node2 node1 .. node3 node1 ~~ node4 node1 == node5 @enduml 横向的链接: @startuml left to right direction frame user1{ card root card sub1 card sub2 } card leaf1 card leaf2 root-->sub1 root-->sub2 sub1-->leaf1 sub1-->leaf2 @enduml 您还可以使用以下类型: @startuml cloud cloud1 cloud cloud2 cloud cloud3 cloud cloud4 cloud cloud5 cloud1 -0- cloud2 cloud1 -0)- cloud3 cloud1 -(0- cloud4 cloud1 -(0)- cloud5 @enduml 包装 @startuml artifact Foo1 { folder Foo2 } folder Foo3 { artifact Foo4 } frame Foo5 { database Foo6 } @enduml @startuml node Foo1 { cloud Foo2 } cloud Foo3 { frame Foo4 } database Foo5 { storage Foo6 } storage Foo7 { storage Foo8 } @enduml 圆角 @startuml skinparam rectangle { roundCorner> 25 } rectangle \"Concept Model\" > { rectangle \"Example 1\" > as ex1 rectangle \"Another rectangle\" } @enduml var className='atoc';"},"2-Chapter/9-定时图.html":{"url":"2-Chapter/9-定时图.html","title":"第二章 第9节：定时图","keywords":"","body":"第二章 第9节：定时图 这只是个提案，主题和内容可能改变 非常欢迎您参与这个新特性的讨论。您的反馈、创意和建议可以帮助我们找寻适合的解决方案。 声明参与者 使用 concise or robust 关键字声明参与者, 选择哪个取决于所需的显示样式。 通过 @ 标注, 和 is 动词定义状态. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Web 浏览器\" as WB concise \"Web 用户\" as WU @0 WU is 空闲 WB is 空闲 @100 WU is 等待中 WB is 处理中 @300 WB is 等待中 @enduml Binary and Clock It's also possible to have binary and clock signal, using the following keywords: binary clock @startuml skinparam defaultFontName \"Source Han Sans SC Light\" clock clk with period 1 binary \"Enable\" as EN @0 EN is low @5 EN is high @10 EN is low @enduml 增加消息 使用下述的语法增加对消息的描述。 @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Web 浏览器\" as WB concise \"Web 用户\" as WU @0 WU is 空闲 WB is 空闲 @100 WU -> WB : URL WU is 等待中 WB is 处理中 @300 WB is 等待中 @enduml 相对时间 It is possible to use relative time with @. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"DNS Resolver\" as DNS robust \"Web Browser\" as WB concise \"Web User\" as WU @0 WU is Idle WB is Idle DNS is Idle @+100 WU -> WB : URL WU is Waiting WB is Processing @+200 WB is Waiting WB -> DNS@+50 : Resolve URL @+100 DNS is Processing @+300 DNS is Idle @enduml Anchor Points Instead of using absolute or relative time on an absolute time you can define a time as an anchor point by using the as keyword and starting the name with a :. @XX as : @startuml skinparam defaultFontName \"Source Han Sans SC Light\" clock clk with period 1 binary \"enable\" as EN concise \"dataBus\" as db @0 as :start @5 as :en_high @10 as :en_low @:start EN is low db is \"0x0000\" @:en_high EN is high @:en_low EN is low @:en_high-2 db is \"0xf23a\" @:en_high+6 db is \"0x0000\" @enduml Participant oriented Rather than declare the diagram in chronological order, you can define it by participant. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Web Browser\" as WB concise \"Web User\" as WU @WB 0 is idle +200 is Proc. +100 is Waiting @WU 0 is Waiting +500 is ok @enduml Setting scale You can also set a specific scale. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" concise \"Web User\" as WU scale 100 as 50 pixels @WU 0 is Waiting +500 is ok @enduml Initial state You can also define an inital state. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Web Browser\" as WB concise \"Web User\" as WU WB is Initializing WU is Absent @WB 0 is idle +200 is Processing +100 is Waiting @WU 0 is Waiting +500 is ok @enduml Intricated state A signal could be in some undefined state. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Signal1\" as S1 robust \"Signal2\" as S2 S1 has 0,1,2,hello S2 has 0,1,2 @0 S1 is 0 S2 is 0 @100 S1 is {0,1} #SlateGrey S2 is {0,1} @200 S1 is 1 S2 is 0 @300 S1 is hello S2 is {0,2} @enduml Hidden state It is also possible to hide some state. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" concise \"Web User\" as WU @0 WU is {-} @100 WU is A1 @200 WU is {-} @300 WU is {hidden} @400 WU is A3 @500 WU is {-} @enduml Hide time axis It is possible to hide time axis. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" hide time-axis concise \"Web User\" as WU WU is Absent @WU 0 is Waiting +500 is ok @enduml Using Time and Date It is possible to use time or date. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Web Browser\" as WB concise \"Web User\" as WU @2019/07/02 WU is Idle WB is Idle @2019/07/04 WU is Waiting : some note WB is Processing : some other note @2019/07/05 WB is Waiting @enduml @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Web Browser\" as WB concise \"Web User\" as WU @1:15:00 WU is Idle WB is Idle @1:16:30 WU is Waiting : some note WB is Processing : some other note @1:17:30 WB is Waiting @enduml Adding constraint It is possible to display time constraints on the diagrams. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Web Browser\" as WB concise \"Web User\" as WU WB is Initializing WU is Absent @WB 0 is idle +200 is Processing +100 is Waiting WB@0 @50 : {50 ms lag} @WU 0 is Waiting +500 is ok @200 @+150 : {150 ms} @enduml Highlighted period You can higlight a part of diagram. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" robust \"Web Browser\" as WB concise \"Web User\" as WU @0 WU is Idle WB is Idle @100 WU -> WB : URL WU is Waiting #LightCyan;line:Aqua @200 WB is Proc. @300 WU -> WB@350 : URL2 WB is Waiting @+200 WU is ok @+200 WB is Idle highlight 200 to 450 #Gold;line:DimGrey : This is my caption @enduml Adding texts You can optionally add a title, a header, a footer, a legend and a caption: @startuml skinparam defaultFontName \"Source Han Sans SC Light\" Title Some title header: Some header footer: Some footer legend Some legend end legend caption Some caption robust \"Web Browser\" as WB concise \"Web User\" as WU @0 WU is Idle WB is Idle @100 WU is Waiting WB is Processing @300 WB is Waiting @enduml Complete example Thanks to Adam Rosien for this example. @startuml skinparam defaultFontName \"Source Han Sans SC Light\" concise \"Client\" as Client concise \"Server\" as Server concise \"Response freshness\" as Cache Server is idle Client is idle @Client 0 is send Client -> Server@+25 : GET +25 is await +75 is recv +25 is idle +25 is send Client -> Server@+25 : GET\\nIf-Modified-Since: 150 +25 is await +50 is recv +25 is idle @100 @275 : no need to re-request from server @Server 25 is recv +25 is work +25 is send Server -> Client@+25 : 200 OK\\nExpires: 275 +25 is idle +75 is recv +25 is send Server -> Client@+25 : 304 Not Modified +25 is idle @Cache 75 is fresh +200 is stale @enduml Digital Example @startuml skinparam defaultFontName \"Source Han Sans SC Light\" scale 5 as 150 pixels clock clk with period 1 binary \"enable\" as en binary \"R/W\" as rw binary \"data Valid\" as dv concise \"dataBus\" as db concise \"address bus\" as addr @6 as :write_beg @10 as :write_end @15 as :read_beg @19 as :read_end @0 en is low db is \"0x0\" addr is \"0x03f\" rw is low dv is 0 @:write_beg-3 en is high @:write_beg-2 db is \"0xDEADBEEF\" @:write_beg-1 dv is 1 @:write_beg rw is high @:write_end rw is low dv is low @:write_end+1 rw is low db is \"0x0\" addr is \"0x23\" @12 dv is high @13 db is \"0xFFFF\" @20 en is low dv is low @21 db is \"0x0\" highlight :write_beg to :write_end #Gold:Write highlight :read_beg to :read_end #lightBlue:Read db@:write_beg-1 @:write_end : setup time db@:write_beg-1 -> addr@:write_end+1 : hold @enduml var className='atoc';"},"2-Chapter/10-线框图形界面.html":{"url":"2-Chapter/10-线框图形界面.html","title":"第二章 第10节：线框图形界面","keywords":"","body":"第二章 第10节：线框图形界面 Salt 是 PlantUML 下面的子项目用来帮助用户来设计图形接口. 可以用 @startsalt 关键字，或者使用 @startuml 紧接着下一行使用salt 关键字. 基本部件 一个窗口必须以中括号开头和结尾。 接着可以这样定义: 按钮用 [ 和 ]。 单选按钮用 ( 和 )。 复选框用 [ 和 ]。 用户文字域用 \"。 @startsalt { Just plain text [This is my button] () Unchecked radio (X) Checked radio [] Unchecked box [X] Checked box \"Enter text here \" ^This is a droplist^ } @endsalt 这个工具是用来讨论简单的示例窗口。 使用表格 当在输入关键词 {后，会自动建立一个表格 当输入| 说明一个单元格 例子如下 @startsalt { Login | \"MyName \" Password | \"**** \" [Cancel] | [ OK ] } @endsalt 在启用关键词后，你可以使用以下字符来绘制表格中的线及列 : Symbol Result # 显示所有垂直水平线 ! 显示所有垂直线 - 显示所有水平线 + 显示外框线 @startsalt {+ Login | \"MyName \" Password | \"**** \" [Cancel] | [ OK ] } @endsalt Group box @startsalt {^\"My group box\" Login | \"MyName \" Password | \"**** \" [Cancel] | [ OK ] } @endsalt 使用分隔符 你可以使用几条横线表示分隔符 @startuml salt { Text1 .. \"Some field\" == Note on usage ~~ Another text -- [Ok] } @enduml 树形外挂 使用树结构，你必须要 以 {T 进行起始，然后使用 + 定义层次。 @startsalt { {T + World ++ America +++ Canada +++ USA ++++ New York ++++ Boston +++ Mexico ++ Europe +++ Italy +++ Germany ++++ Berlin ++ Africa } } @endsalt Enclosing brackets You can define subelements by opening a new opening bracket. @startsalt { Name | \" \" Modifiers: | { (X) public | () default | () private | () protected [] abstract | [] final | [] static } Superclass: | { \"java.lang.Object \" | [Browse...] } } @endsalt 添加选项卡 你可以通过 {/ 标记增加对应的选项卡。 注意：可以使用HTML 代码来增加粗体效果。 @startsalt {+ {/ General | Fullscreen | Behavior | Saving } { { Open image in: | ^Smart Mode^ } [X] Smooth images when zoomed [X] Confirm image deletion [ ] Show hidden images } [Close] } @endsalt 可以定义垂直选项卡，如下: @startsalt {+ {/ General Fullscreen Behavior Saving } | { { Open image in: | ^Smart Mode^ } [X] Smooth images when zoomed [X] Confirm image deletion [ ] Show hidden images [Close] } } @endsalt 使用菜单 你可以使用记号{*来添加菜单。 @startsalt {+ {* File | Edit | Source | Refactor } {/ General | Fullscreen | Behavior | Saving } { { Open image in: | ^Smart Mode^ } [X] Smooth images when zoomed [X] Confirm image deletion [ ] Show hidden images } [Close] } @endsalt 你也可以打开一个菜单： @startsalt {+ {* File | Edit | Source | Refactor Refactor | New | Open File | - | Close | Close All } {/ General | Fullscreen | Behavior | Saving } { { Open image in: | ^Smart Mode^ } [X] Smooth images when zoomed [X] Confirm image deletion [ ] Show hidden images } [Close] } @endsalt 高级表格 对于表格有两种特殊的标记 : * 单元格同时具备 span 和 left 两个属性 . 是空白单元格 @startsalt {# . | Column 2 | Column 3 Row header 1 | value 1 | value 2 Row header 2 | A long cell | * } @endsalt OpenIconic OpenIconic is an very nice open source icon set. Those icons have been integrated into the creole parser, so you can use them out-of-the-box. You can use the following syntax: . @startsalt { Login | \"MyName \" Password | \"**** \" [Cancel ] | [OK ] } @endsalt The complete list is available on OpenIconic Website, or you can use the following special diagram: @startuml listopeniconic @enduml Include Salt You can read the following explanation. @startuml (*) --> \" {{ salt {+ an example choose one option ()one ()two [ok] } }} \" as choose choose -right-> \" {{ salt {+ please wait operation in progress [cancel] } }} \" as wait wait -right-> \" {{ salt {+ success congratulations! [ok] } }} \" as success wait -down-> \" {{ salt {+ error failed, sorry [ok] } }} \" @enduml It can also be combined with define macro. @startuml !unquoted procedure SALT($x) \"{{ salt %invoke_procedure(\"_\"+$x) }}\" as $x !endprocedure !procedure _choose() {+ an example choose one option ()one ()two [ok] } !endprocedure !procedure _wait() {+ please wait operation in progress [cancel] } !endprocedure !procedure _success() {+ success congratulations! [ok] } !endprocedure !procedure _error() {+ error failed, sorry [ok] } !endprocedure (*) --> SALT(choose) -right-> SALT(wait) wait -right-> SALT(success) wait -down-> SALT(error) @enduml Scroll Bars You can use \"S\" as scroll bar like in following examples: @startsalt {S Message . . . . } @endsalt @startsalt {SI Message . . . . } @endsalt @startsalt {S- Message . . . . } @endsalt var className='atoc';"},"2-Chapter/11-架构图.html":{"url":"2-Chapter/11-架构图.html","title":"第二章 第11节：架构图","keywords":"","body":"第二章 第11节：架构图 This is only a proposal and subject to change. You are very welcome to create a new discussion on this future syntax. Your feedbacks, ideas and suggestions help us to find the right solution. Archimate keyword You can use the archimate keyword to define an element. Stereotype can optionally specify an additional icon. Some colors (Business, Application, Motivation, Strategy, Technology, Physical, Implementation) are also available. @startuml archimate #Technology \"VPN Server\" as vpnServerA > rectangle GO #lightgreen rectangle STOP #red rectangle WAIT #orange @enduml Defining Junctions Using the circle keyword and the preprocessor, you can also create junctions. @startuml !define Junction_Or circle #black !define Junction_And circle #whitesmoke Junction_And JunctionAnd Junction_Or JunctionOr archimate #Technology \"VPN Server\" as vpnServerA > rectangle GO #lightgreen rectangle STOP #red rectangle WAIT #orange GO -up-> JunctionOr STOP -up-> JunctionOr STOP -down-> JunctionAnd WAIT -down-> JunctionAnd @enduml Example 1 @startuml skinparam rectangle> { roundCorner 25 } sprite $bProcess jar:archimate/business-process sprite $aService jar:archimate/application-service sprite $aComponent jar:archimate/application-component rectangle \"Handle claim\" as HC >> #Business rectangle \"Capture Information\" as CI >> #Business rectangle \"Notify\\nAdditional Stakeholders\" as NAS >> #Business rectangle \"Validate\" as V >> #Business rectangle \"Investigate\" as I >> #Business rectangle \"Pay\" as P >> #Business HC *-down- CI HC *-down- NAS HC *-down- V HC *-down- I HC *-down- P CI -right->> NAS NAS -right->> V V -right->> I I -right->> P rectangle \"Scanning\" as scanning >> #Application rectangle \"Customer admnistration\" as customerAdministration >> #Application rectangle \"Claims admnistration\" as claimsAdministration >> #Application rectangle Printing >> #Application rectangle Payment >> #Application scanning -up-> CI customerAdministration -up-> CI claimsAdministration -up-> NAS claimsAdministration -up-> V claimsAdministration -up-> I Payment -up-> P Printing -up-> V Printing -up-> P rectangle \"Document\\nManagement\\nSystem\" as DMS > #Application rectangle \"General\\nCRM\\nSystem\" as CRM > #Application rectangle \"Home & Away\\nPolicy\\nAdministration\" as HAPA > #Application rectangle \"Home & Away\\nFinancial\\nAdministration\" as HFPA > #Application DMS .up.|> scanning DMS .up.|> Printing CRM .up.|> customerAdministration HAPA .up.|> claimsAdministration HFPA .up.|> Payment legend left Example from the \"Archisurance case study\" (OpenGroup). See == :business process == : application service == : application component endlegend @enduml Example 2 @startuml skinparam roundcorner 25 rectangle \"Capture Information\" as CI > #Business @enduml List possible sprites You can list all possible sprites for Archimate using the following diagram: @startuml listsprite @enduml ArchiMate Macros A list of Archimate marcros are defined Archimate-PlantUML here which simplifies the creation of ArchiMate diagrams. Using the macros, creation of ArchiMate elements are done using the following format: Category_ElementName(nameOfTheElement, \"description\") For Example: To define a Stakeholder element, which is part of Motivation category, the syntax will be Motivation_Stakeholder(StakeholderElement, \"Stakeholder Description\") To define a Business Service element, Business_Service(BService, \"Business Service\") The ArchiMate relationships are defined with the following pattern: Rel_RelationType(fromElement, toElement, \"description\") and to define the direction / orientation of the two elements: Rel_RelationType_Direction(fromElement, toElement, \"description\") The RelationTypes supported are: Access Aggregation Assignment Association Composition Flow Influence Realization Serving Specilization Triggering The Directions supported are: Up Down Left Right For example: To denote a composition relationship between the Stakeholder and Business Service defined above, the syntax will be Rel_Composition(StakeholderElement, BService, \"Description for the relationship\") Unordered List ItemTo orient the two elements in top - down position, the syntax will be Rel_Composition_Down(StakeholderElement, BService, \"Description for the relationship\") var className='atoc';"},"2-Chapter/12-规范和描述语言SDL.html":{"url":"2-Chapter/12-规范和描述语言SDL.html","title":"第二章 第12节：规范和描述语言SDL","keywords":"","body":"第二章 第12节：规范和描述语言SDL 同活动图(新语法) var className='atoc';"},"2-Chapter/13-Ditaa diagram.html":{"url":"2-Chapter/13-Ditaa diagram.html","title":"第二章 第13节：Ditaa diagram","keywords":"","body":"第二章 第13节：Ditaa diagram 原来，图表的描述需要以\"@startuml\"开头，以@enduml结束，PlantUML在支持UML同时支持其他图表，既然如此，\"@startuml\"就没有存在的必要了。 所以，通用规则允许图表描述以@startXYZ开头，以@endXYZ结束，\"XYZ\"根据图表的类型而改变。 注意，XYZ可以是任何字符串（包括空格）。 这意味着我们鼓励插件开发者，以@start代替@startuml作为标识。 Ditaa Ditaa 是一个支持通过文本描述生成通用图表的开源项目。这个理念和PlantUML非常相近，所以，支持除UML之外其他图表的文档化将会很有很有意义。 所以最新版本的PlantUML支持下面的语法： @startuml ditaa +--------+ +-------+ +-------+ | +---+ ditaa +--> | | | Text | +-------+ |diagram| |Document| |!magic!| | | | {d}| | | | | +---+----+ +-------+ +-------+ : ^ | Lots of work | +-------------------------+ @enduml 你可以在 这里 找到它的完整的文档。 如果你的插件还不支持@startditaa，可以使用 临时 解决方案：在你的文档描述首行使用@startuml，通过ditta关键字来支持 Ditaa 。 你同样可以在@startditaa或者@ditta关键字后面使用一些设置： -E 或者 --no-separation 移除分隔符 -S 或者 --no-shadows 移除阴影 scale=XYZ to 缩放图表 @startuml ditaa(--no-shadows, scale=0.8) /--------\\ +-------+ |cAAA +---+Version| | Data | | V3 | | Base | |cRED{d}| | {s}| +-------+ \\---+----/ @enduml 只支持PNG格式。 DOT 自从 PlantUML 使用 Graphviz/DOT语法，直接使用DOT语言成为可能。 这意味着你可以使用 Graphviz/DOT 所有支持PlantUML的工具。 注意，起始行必须是： digraph XYZ { 注意，你同样可以使用@startuml/@enduml代替@startdot/@enddot： 这里有一个实例： @startuml digraph foo { node [style=rounded] node1 [shape=box] node2 [fillcolor=yellow, style=\"rounded,filled\", shape=diamond] node3 [shape=record, label=\"{ a | b | c }\"] node1 -> node2 -> node3 } @enduml var className='atoc';"},"2-Chapter/14-甘特图 .html":{"url":"2-Chapter/14-甘特图 .html","title":"第二章 第14节：甘特图 ","keywords":"","body":"第二章 第14节：甘特图 This is only a proposal and subject to change. You are very welcome to create a new discussion on this future syntax. Your feedbacks, ideas and suggestions help us to find the right solution. The Gantt is described in natural language, using very simple sentences (subject-verb-complement). Declaring tasks Tasks defined using square bracket. Their durations are defined using the last verb: @startuml [Prototype design] lasts 15 days [Test prototype] lasts 10 days @enduml Adding constraints It is possible to add constraints between task. @startuml [Prototype design] lasts 15 days [Test prototype] lasts 10 days [Test prototype] starts at [Prototype design]'s end @enduml @startuml [Prototype design] lasts 10 days [Code prototype] lasts 10 days [Write tests] lasts 5 days [Code prototype] starts at [Prototype design]'s end [Write tests] starts at [Code prototype]'s start @enduml Short names It is possible to define short name for tasks with the as keyword. @startuml [Prototype design] as [D] lasts 15 days [Test prototype] as [T] lasts 10 days [T] starts at [D]'s end @enduml Customize colors It also possible to customize colors. @startuml [Prototype design] lasts 13 days [Test prototype] lasts 4 days [Test prototype] starts at [Prototype design]'s end [Prototype design] is colored in Fuchsia/FireBrick [Test prototype] is colored in GreenYellow/Green @enduml Completion status You can set the completion status of a task. @startgantt [foo] lasts 21 days [foo] is 40% completed [bar] lasts 30 days and is 10% complete @endgantt Milestone You can define Milestones using the happens verb. @startuml [Test prototype] lasts 10 days [Prototype completed] happens at [Test prototype]'s end [Setup assembly line] lasts 12 days [Setup assembly line] starts at [Test prototype]'s end @enduml Hyperlinks You can add hyperlinks to tasks. @startgantt [task1] lasts 10 days [task1] links to [[http://plantuml.com]] @endgantt Calendar You can specify a starting date for the whole project. By default, the first task starts at this date. @startuml Project starts the 20th of september 2017 [Prototype design] as [TASK1] lasts 13 days [TASK1] is colored in Lavender/LightBlue @enduml Changing scale You can change scale for very long project @startgantt printscale weekly Project starts the 20th of september 2020 [Prototype design] as [TASK1] lasts 130 days [TASK1] is colored in Lavender/LightBlue [Testing] lasts 20 days [TASK1]->[Testing] @endgantt Close day It is possible to close some day. @startuml project starts the 2018/04/09 saturday are closed sunday are closed 2018/05/01 is closed 2018/04/17 to 2018/04/19 is closed [Prototype design] lasts 14 days [Test prototype] lasts 4 days [Test prototype] starts at [Prototype design]'s end [Prototype design] is colored in Fuchsia/FireBrick [Test prototype] is colored in GreenYellow/Green @enduml Simplified task succession It's possible to use the then keyword to denote consecutive tasks. @startuml [Prototype design] lasts 14 days then [Test prototype] lasts 4 days then [Deploy prototype] lasts 6 days @enduml You can also use arrow -> @startuml [Prototype design] lasts 14 days [Build prototype] lasts 4 days [Prepare test] lasts 6 days [Prototype design] -> [Build prototype] [Prototype design] -> [Prepare test] @enduml Separator You can use -- to separate sets of tasks. @startuml [Task1] lasts 10 days then [Task2] lasts 4 days -- Phase Two -- then [Task3] lasts 5 days then [Task4] lasts 6 days @enduml Working with resources You can affect tasks on resources using the on keyword and brackets for resource name. @startuml [Task1] on {Alice} lasts 10 days [Task2] on {Bob:50%} lasts 2 days then [Task3] on {Alice:25%} lasts 1 days @enduml Complex example It also possible to use the and conjunction. You can also add delays in constraints. @startuml [Prototype design] lasts 13 days and is colored in Lavender/LightBlue [Test prototype] lasts 9 days and is colored in Coral/Green and starts 3 days after [Prototype design]'s end [Write tests] lasts 5 days and ends at [Prototype design]'s end [Hire tests writers] lasts 6 days and ends at [Write tests]'s start [Init and write tests report] is colored in Coral/Green [Init and write tests report] starts 1 day before [Test prototype]'s start and ends at [Test prototype]'s end @enduml var className='atoc';"},"2-Chapter/15-思维导图.html":{"url":"2-Chapter/15-思维导图.html","title":"第二章 第15节：思维导图","keywords":"","body":"第二章 第15节：思维导图 于测试阶段：语法随时可能更改。 OrgMode 语法 同时兼容OrgMode语法。 @startmindmap * Debian ** Ubuntu *** Linux Mint *** Kubuntu *** Lubuntu *** KDE Neon ** LMDE ** SolydXK ** SteamOS ** Raspbian with a very long name *** Raspmbc => OSMC *** Raspyfi => Volumio @endmindmap Multilines You can use : and ; to have multilines box. @startmindmap * Class Templates **:template class cname{ void f1() ... }; **:other template class cname{ ... }; @endmindmap Colors It is possible to change node color. @startmindmap *[#Orange] Colors **[#lightgreen] Green **[#FFBBCC] Rose **[#lightblue] Blue @endmindmap 去除外边框 你可以用下划线去除外边框。 @startmindmap * root node ** some first level node ***_ second level node ***_ another second level node ***_ foo ***_ bar ***_ foobar ** another first level node @endmindmap 运算符 你可以使用下面的运算符来决定图形方向。 @startmindmap + OS ++ Ubuntu +++ Linux Mint +++ Kubuntu +++ Lubuntu +++ KDE Neon ++ LMDE ++ SolydXK ++ SteamOS ++ Raspbian -- Windows 95 -- Windows 98 -- Windows NT --- Windows 8 --- Windows 10 @endmindmap Markdown语法 同时兼容Markdown语法。 @startmindmap * root node * some first level node * second level node * another second level node * another first level node @endmindmap 改变图形方向 你可以同时使用图形的左右两侧。 @startmindmap * count ** 100 *** 101 *** 102 ** 200 left side ** A *** AA *** AB ** B @endmindmap 完整示例 @startmindmap caption figure 1 title My super title * Debian ** Ubuntu *** Linux Mint *** Kubuntu *** Lubuntu *** KDE Neon ** LMDE ** SolydXK ** SteamOS ** Raspbian with a very long name *** Raspmbc => OSMC *** Raspyfi => Volumio header My super header endheader center footer My super footer legend right Short legend endlegend @endmindmap var className='atoc';"},"2-Chapter/16-工作分解结构图.html":{"url":"2-Chapter/16-工作分解结构图.html","title":"第二章 第16节：工作分解结构图","keywords":"","body":"第二章 第16节：工作分解结构图 WBS diagram are still in beta: the syntax may change without notice. OrgMode syntax This syntax is compatible with OrgMode @startwbs * Business Process Modelling WBS ** Launch the project *** Complete Stakeholder Research *** Initial Implementation Plan ** Design phase *** Model of AsIs Processes Completed **** Model of AsIs Processes Completed1 **** Model of AsIs Processes Completed2 *** Measure AsIs performance metrics *** Identify Quick Wins ** Complete innovate phase @endwbs Change direction You can change direction using and > @startwbs * Business Process Modelling WBS ** Launch the project *** Complete Stakeholder Research *** Initial Implementation Plan ** Design phase *** Model of AsIs Processes Completed **** Model of AsIs Processes Completed2 *** Arithmetic notation You can use the following notation to choose diagram side. @startwbs + New Job ++ Decide on Job Requirements +++ Identity gaps +++ Review JDs ++++ Sign-Up for courses ++++ Volunteer ++++ Reading ++- Checklist +++- Responsibilities +++- Location ++ CV Upload Done +++ CV Updated ++++ Spelling & Grammar ++++ Check dates ---- Skills +++ Recruitment sites chosen @endwbs You can use underscore _ to remove box drawing. @startwbs + Project + Part One + Task 1.1 - LeftTask 1.2 + Task 1.3 + Part Two + Task 2.1 + Task 2.2 -_ Task 2.2.1 To the left boxless -_ Task 2.2.2 To the Left boxless +_ Task 2.2.3 To the right boxless @endwbs var className='atoc';"},"2-Chapter/17-数学公式.html":{"url":"2-Chapter/17-数学公式.html","title":"第二章 第17节：数学公式","keywords":"","body":"第二章 第17节：数学公式 简介 您可以在PlantUML中用AsciiMath 或JLaTeXMath 符号: @startuml :int_0^1f(x)dx; :x^2+y_1+z_12^34; note right Try also d/dxf(x)=lim_(h->0)(f(x+h)-f(x))/h P(y|\\mathbf{x}) \\mbox{ or } f(\\mathbf{x})+\\epsilon end note @enduml 或: @startuml Bob -> Alice : Can you solve: ax^2+bx+c=0 Alice --> Bob: x = (-b+-sqrt(b^2-4ac))/(2a) @enduml 独立图 您也可以用 @startmath/@endmath 来创建独立的 AsciiMath 公式。 @startmath f(t)=(a_0)/2 + sum_(n=1)^ooa_ncos((npit)/L)+sum_(n=1)^oo b_n\\ sin((npit)/L) @endmath 或用 @startlatex/@endlatex 来创建独立的 JLaTeXMath 公式。 @startlatex \\sum_{i=0}^{n-1} (a_i + b_i^2) @endlatex 这是如何工作的 ? 要绘制这此公式, PlantUML 使用了两个开源项目： AsciiMath 转换 AsciiMath 符号为 LaTeX 表达式。 JLatexMath 来显示LaTex 数学公式。 JLaTeXMath 是最好的显示LaTeX代码的 Java 类库。 ASCIIMathTeXImg.js 是一个小到足以集成到 PlantUML 标准发版的。 由于 JLatexMath 太大, 您要单独到 下载它, 然后解压 4 jar 文件 (batik-all-1.7.jar, jlatexmath-minimal-1.0.3.jar, jlm_cyrillic.jar 和 jlm_greek.jar) 到 PlantUML.jar同一目录下。 var className='atoc';"},"2-Chapter/18-Entity Relationship diagram.html":{"url":"2-Chapter/18-Entity Relationship diagram.html","title":"第二章 第18节：Entity Relationship diagram","keywords":"","body":"第二章 第18节：Entity Relationship diagram Based on the Information Engineering notation. This is an extension to the existing Class Diagram. This extension adds: Additional relations for the Information Engineering notation. An entity alias that maps to the class diagram class. An additional visibility modifier * to identify mandatory attributes. Otherwise, the syntax for drawing diagrams is the same as for class diagrams. All other features of class diagrams are also supported. Information Engineering Relations Type Symbol Zero or One \\color{fuchsia}{\\verb+|o--+} Exactly One \\color{fuchsia}{\\verb+||--+} Zero or Many \\color{fuchsia}{\\}\\verb+o--+} One or Many \\color{fuchsia}{\\}\\verb+|--+} Examples: @startuml Entity01 }|..|| Entity02 Entity03 }o..o| Entity04 Entity05 ||--o{ Entity06 Entity07 |o--|| Entity08 @enduml Entities @startuml entity Entity01 { * identifying_attribute -- * mandatory_attribute optional_attribute } @enduml Again, this is the normal class diagram syntax (aside from use of entity instead of class). Anything that you can do in a class diagram can be done here. The * visibility modifier can be used to identify mandatory attributes. A space can be used after the modifier character to avoid conflicts with the creole bold: @startuml entity Entity01 { optional attribute **optional bold attribute** * **mandatory bold attribute** } @enduml Complete Example @startuml ' hide the spot hide circle ' avoid problems with angled crows feet skinparam linetype ortho entity \"Entity01\" as e01 { *e1_id : number > -- *name : text description : text } entity \"Entity02\" as e02 { *e2_id : number > -- *e1_id : number > other_details : text } entity \"Entity03\" as e03 { *e3_id : number > -- e1_id : number > other_details : text } e01 ||..o{ e02 e01 |o..o{ e03 @enduml Currently the crows feet do not look very good when the relationship is drawn at an angle to the entity. This can be avoided by using the linetype ortho skinparam. var className='atoc';"},"2-Chapter/19-nwdiag.html":{"url":"2-Chapter/19-nwdiag.html","title":"第二章 第19节：nwdiag","keywords":"","body":"第二章 第19节：nwdiag nwdiag has been created by Takeshi Komiya and allows to quickly draw network diagrams. So we thank him for his creation! Since the syntax is clear and simple, this has been integrated within PlantUML. We reuse here the examples that Takeshi has documented. Simple diagram @startuml nwdiag { network dmz { address = \"210.x.x.x/24\" web01 [address = \"210.x.x.1\"]; web02 [address = \"210.x.x.2\"]; } network internal { address = \"172.x.x.x/24\"; web01 [address = \"172.x.x.1\"]; web02 [address = \"172.x.x.2\"]; db01; db02; } } @enduml define multiple addresses @startuml nwdiag { network dmz { address = \"210.x.x.x/24\" // set multiple addresses (using comma) web01 [address = \"210.x.x.1, 210.x.x.20\"]; web02 [address = \"210.x.x.2\"]; } network internal { address = \"172.x.x.x/24\"; web01 [address = \"172.x.x.1\"]; web02 [address = \"172.x.x.2\"]; db01; db02; } } @enduml grouping nodes Not fully implemented yet @startuml nwdiag { network Sample_front { address = \"192.168.10.0/24\"; // define group group web { web01 [address = \".1\"]; web02 [address = \".2\"]; } } network Sample_back { address = \"192.168.20.0/24\"; web01 [address = \".1\"]; web02 [address = \".2\"]; db01 [address = \".101\"]; db02 [address = \".102\"]; // define network using defined nodes group db { db01; db02; } } } @enduml @startuml nwdiag { // define group at outside network definitions group { color = \"#FF7777\"; web01; web02; db01; } network dmz { web01; web02; } network internal { web01; web02; db01; } } @enduml Extended Syntax @startuml nwdiag { network Sample_front { address = \"192.168.10.0/24\" color = \"red\" // define group group web { web01 [address = \".1\", shape = \"node\"] web02 [address = \".2\"] } } network Sample_back { address = \"192.168.20.0/24\" web01 [address = \".1\"] web02 [address = \".2\"] db01 [address = \".101\", shape = database ] db02 [address = \".102\"] // define network using defined nodes group db { db01; db02; } } } @enduml peer networks @startuml nwdiag { inet [shape = cloud]; inet -- router; network { router; web01; web02; } } @enduml var className='atoc';"},"2-Chapter/20-PlantUML绘制23种设计模式.html":{"url":"2-Chapter/20-PlantUML绘制23种设计模式.html","title":"第二章 第20节：PlantUML绘制23种设计模式","keywords":"","body":"第二章 第20节：PlantUML绘制23种设计模式 参考链接： 设计模式概念含结构说明: http://c.biancheng.net/view/1317.html 设计模式概念丰富:https://www.runoob.com/design-pattern/design-pattern-tutorial.html 设计模式概念描述不一致: https://blog.csdn.net/zxh2075/article/details/80164113 设计模式PlantUML: https://blog.csdn.net/u010144805/article/details/82415385 设计模式C++: https://gitee.com/micooz/DesignPattern 设计模式C++: https://github.com/micooz/DesignPattern 类的关系: https://www.cnblogs.com/pangjianxin/p/7877868.html 类的关系: https://www.cnblogs.com/qianpangzi/p/10842672.html UML类图几种关系的总结泛化 实线三角指向父类；实现 虚线三角指向接口； 组合 实心菱形精密关联不可分，是组合；聚合 空心菱形能分离而独立存在，是聚合； 关联 实线箭头指向关联，箭头代表拥有，箭头指向被拥有者；依赖 虚线箭头指向依赖； 各种关系的强弱顺序：泛化= 实现> 组合> 聚合> 关联> 依赖 单例模式(Singleton pattern) 单例模式(Singleton pattern): 确保一个类只有一个实例, 并提供全局访问点. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Singleton(单例模式)\" #DDDDDD { class Singleton { +getInstance():Singleton -Singleton() } note right: 单例类 Singleton 生成器模式(Builder pattern) 使用生成器模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Builder(生成器模式)\" #DDDDDD { abstract class Builder { +buildPartA():void +buildPartB():void +buildPartC():void } note right: 抽象Builder类 class ConcreteBuilder { +buildPartA():void +buildPartB():void +buildPartC():void } note right: 具体Builder类 class Director { +construct() } note right:统一组装过程 abstract class Product note right:产品的抽象类 Director o-- Builder Builder > } @enduml 原型模式(prototype pattern) 当创建给定类的实例过程很昂贵或很复杂时, 就使用原形模式. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Protype(原型模式)\" #DDDDDD { class Protype> { +clone() } note right: 原型的抽象类或接口 class ConcreteProtype { +clone() } note right: 具体的原型类 Protype Protype:> } @enduml 工厂方法模式(factorymethod pattern) 定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class FactoryMethod(工厂方法模式)\" #DDDDDD { abstract class Factory { +createProduct():Product } class ConcreteFactory { +createProduct():Product } abstract class Product { +method():void } class ConcreteProduct { +method():void } Product 抽象工厂模式(Abstractfactory pattern) 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要指定具体类. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class AbstractFactory(抽象工厂模式)\" #DDDDDD { abstract class AbstractProductA { +method():void } abstract class AbstractProductB { +method():void } class ConcreteProductA1 { +method():void } class ConcreteProductA2 { +method():void } class ConcreteProductB1 { +method():void } class ConcreteProductB2 { +method():void } abstract class AbstractFactory { +createProductA():AbstractProductA +createProductB():AbstractProductB } note top of AbstractFactory: 抽象工厂 class ConcreteFactory1 { +createProductA():AbstractProductA +createProductB():AbstractProductB } class ConcreteFactory2 { +createProductA():AbstractProductA +createProductB():AbstractProductB } AbstractProductA ConcreteProductA1 ConcreteFactory1 ..> ConcreteProductB1 ConcreteFactory2 ..> ConcreteProductA2 ConcreteFactory2 ..> ConcreteProductB2 } @enduml 代理模式(Proxy pattern) 为另一个对象提供一个替身或占位符以控制对这个对象的访问. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Proxy(代理模式)\" #DDDDDD { class Client abstract class Subject { +visit() } note right: 抽象主题类 class RealSubject { +visit() } note right: 真实主题类 class ProxySubject{ -mSubject:RealSubject +visit() } note right: 代理类 Subject 适配器模式(Adapter pattern) 将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Adapter(适配器模式)\" #DDDDDD { class Target>{ +operation1() +operation2():void } note right: 目标 class Adapter{ + operation2() } note right: 适配器 class Adaptee{ + operation3() } note right: 需要适配的接口 Target 组合模式(composite pattern) 允许你将对象组合成树形结构来表现\"整体/部分\"层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Composite(组合模式)\" #DDDDDD { class Client abstract class Component{ #name:String +Component(String):void +doSomething():void } class Leaf{ +Component(String):void +doSomething():void } class Composite{ -components:List +Component(String):void +doSomething():void +addChild(Component):void +getChildren(int):Component +removeChild(Component):void } Component 装饰者模式(decorator pattern) 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Decorator(装饰模式)\" #DDDDDD { abstract class Component { + operate():void } note top of Component: 抽象组件 class ConcreteComponent { + operate():void } note top of ConcreteComponent: 组件具体实现类 abstract class Decorator { - component:Component + Decorator(Component) + operate():void } note left: 抽象类装饰者 class ConreteDecoratorA { + ConreteDecoratorA(Component) + operate():void + operateA():void + operateB():void } class ConreteDecoratorB { + ConreteDecoratorB(Component) + operate():void + operateA():void + operateB():void } Component Decorator ConreteDecoratorB --|> Decorator } @enduml 享元模式(FlyweightPattern) 如想让某个类的一个实例能用来提供许多\"虚拟实例\", 就使用享元模式. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Flyweight(享元模式)\" #DDDDDD { class FlyweightFactory{ - mMap:HashMap + getFlyweight() } note right: 享元工厂 class Flyweight{ + dosomething() } note right: 享元对象抽象基类或者接口 class ConcreteFlyweight{ - intrinsicState:String + dosomething() } note right: 具体的享元对象 FlyweightFactory *-- Flyweight Flyweight 外观模式(facade pattern) 提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Facade(外观模式)\" #DDDDDD { class Facade{ + operationA() + operationB():void + operationC():void } note right: 系统对外的统一接口 class SystemA > class SystemB > class SystemC > Facade --> SystemA:> Facade --> SystemB:> Facade --> SystemC:> } @enduml 桥接模式(Bridge pattern) 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Bridge(桥接模式)\" #DDDDDD { abstract class Abstraction Abstraction : +operation() note right: 抽象部分 class RefinedAbstraction note top of RefinedAbstraction:优化的抽象部分 interface Implementor Implementor : +operationImpl() note right:实现部分 class Client note right : 客户端 ConcreteImplementorA : +operationImpl() ConcreteImplementorB : +operationImpl() Client --> Abstraction RefinedAbstraction --|> Abstraction Implementor --o Abstraction ConcreteImplementorA ..|> Implementor ConcreteImplementorB ..|> Implementor } @enduml 策略模式(strategy pattern) 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Strategy(策略模式)\" #DDDDDD { interface Strategy { +algorithm() } note right: 策略的抽象 class ConcreteStrategyA { +algorithm() } class ConcreteStrategyB { +algorithm() } class Context { +setStrategy(Strategy) +algorithm() } note right:上下文环境 Context o-- Strategy Strategy 状态模式(State pattern) 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class State(状态模式)\" #DDDDDD { interface State { +doSomething():void } note right: 抽象状态类或状态接口 class ConcreteStateA { +doSomething():void } class ConcreteStateB { +doSomething():void } class Context { +addState(State) +doSomething():void } note right:环境类 Context -- State State 责任链模式(Chainofresponsibility pattern) 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class ChainOfResponsibility(责任链模式)\" #DDDDDD { abstract class Handler { #successor():Handler +handleRequest(String):void } note left: 抽象处理者 class ConcreteHandler1 { +handleRequest(String):void } class ConcreteHandler2 { +handleRequest(String):void } Handler o-- Handler:0..1 Handler Handler } @enduml 解释器模式(Interpreter pattern) 使用解释器模式为语言创建解释器. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Interpreter(解释器模式)\" #DDDDDD { abstract class AbstractExpression { +interpret(context) } note top of AbstractExpression: 抽象表达式 class TerminalExpression { +interpret(context) } note bottom of TerminalExpression: 终结符表达式 class NonTerminalExpression { +interpret(context) } note bottom of NonTerminalExpression: 非终结符表达式 class Context note top of Context: 上下文 AbstractExpression 命令模式(Command pattern) 将\"请求\"封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Comand(命令模式)\" #DDDDDD { class Invoker { -comand:Comand +Invoker(Comand) +action():void } note right: 请求者 class Receiver { -comand:Comand +action():void } note right: 接收者 class Comand> { +execute():void } note right: 命令 class ConcreteComand { -receiver:Receiver +ConcreteComand(Comand) +execute():void } note right: 具体命令 Client..>Invoker Client..>Receiver Invoker o--> Comand Receiver 观察者模式(observer pattern) 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Observer(观察者模式)\" #DDDDDD { class Subject> { +notifyObservers(Object) } note right: 抽象主题 class ConcreteSubject { +notifyObservers(Object) } note right: 具体主题 class Observer> { +update(Object) } note right: 抽象观察者 class ConcreteObserver { +update(Object) } note right: 具体观察者 Subject 备忘录模式(Memento pattern) 当你需要让对象返回之前的状态时(例如, 你的用户请求\"撤销\"), 你使用备忘录模式. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Memento(备忘录模式)\" #DDDDDD { class Originator { +restore(Memento) +createMemento():Memento } note right: 负责创建备忘录 class Memento { -mState +setState(int) +getState():int } note right: 备忘录 class Caretaker { -mMemento:Memento +restoreMemento():Memento +storeMemento(Memento):void } note right:负责存储备忘录 Originator ..> Memento Memento --o Caretaker } @enduml 迭代器模式(iterator pattern) 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Iterator(迭代器模式)\" #DDDDDD { class Iterator>{ +next():Object +hasNext():boolean } note right: 迭代器接口 class ConcreteIterator{ +next():Object +hasNext():boolean } note right: 具体迭代器类 class Aggregate>{ +add(Object):void +remove(Object):void +iterator():Iterator } note right: 容器接口 class ConcreteAggregate{ +add(Object):void +remove(Object):void +iterator():Iterator } note right: 具体容器类 Iterator 模板方法模式(Template pattern) 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Template(模板方法模式)\" #DDDDDD { class AbsTemplate>{ #stepOne():void #stepTwo():void #stepThree():void +execute():void } note right: 定义算法框架的抽象类 class ConcreteImplA note right: 具体实现类A class ConcreteImplB note right: 具体实现类B AbsTemplate 访问者模式(visitor pattern) 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Visitor(访问者模式)\" #DDDDDD { class Visitor> { +visitElementA(ElementA):void +visitElementB(ElementB):void } note top of Visitor: 访问者接口或抽象类 class ConcreteVisitorA { +visitElementA(ElementA):void +visitElementB(ElementB):void } class ConcreteVisitorB { +visitElementA(ElementA):void +visitElementB(ElementB):void } class Element> { +accept(Visitor) } note top of Element: 元素接口或抽象类 class ElementA { +accept(Visitor) +operationA() } class ElementB { +accept(Visitor) +operationB() } class ObjectStructure note bottom of ObjectStructure: 管理元素集合的对象结构 class Client Visitor Visitor:> Client ..> ObjectStructure:> } @enduml 中介者模式(Mediator pattern) 使用中介者模式来集中相关对象之间复杂的沟通和控制方式. @startuml skinparam classAttributeIconSize 0 skinparam defaultFontName \"Source Han Sans SC Light\" package \"class Mediator(中介者模式)\" #DDDDDD { abstract class Colleague { #mediator:Mediator +Colleague(Mediator) +action():void } note top of Colleague: 抽象同事类 class ConcreteColleagueA { +ConcreteColleagueA(Mediator) +action():void } class ConcreteColleagueB { +ConcreteColleagueB(Mediator) +action():void } class ConcreteMediator { +method():void } note top of ConcreteMediator: 具体中介者 abstract class Mediator{ #colleagueA:ConcreteColleagueA #colleagueB:ConcreteColleagueB +method():void +setConcreteColleagueA(ConcreteColleagueA +setConcreteColleagueB(ConcreteColleagueB) } note bottom of Mediator: 抽象中介者 Colleague Mediator } @enduml 设计模式的七大原则 1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写LKP），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。英文简写为: LoD. 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 7、 单一职责原则的定义 单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。 该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 var className='atoc';"},"3-Chapter/0-README.html":{"url":"3-Chapter/0-README.html","title":"第三章 Mermaid 图表指导手册","keywords":"","body":"第三章 Mermaid 图表指导手册 Mermaid 语法参考官网 Mermaid 在线编辑器 mermaid-gb3 插件存在的问题: 包含的mermaid版本太低 仅支持流程图、序列图、甘特图,其他不支持 图表文字显示不全 无法转成PDF mermaid-newface 插件存在的问题: 不支持Class Diagram、User Journey，其他图表支持正常。 与Typora实时渲染语法不一致。 需要刷新才能看到图表 导出PDF效果未测 总结: mermaid各个插件均存在不同程度的问题，一律使用PlantUML替代。 如果确实需要，使用Mermaid live editor编辑图表并导出使用。 如果确实需要，使用Typora渲染Mermaid图表并导出图像文件使用。 var className='atoc';"},"3-Chapter/1-Flowchart.html":{"url":"3-Chapter/1-Flowchart.html","title":"第三章 第1节：Flowchart","keywords":"","body":"第三章 第1节：Flowchart graph TD Start --> Stop graph TD Start --> Stop graph TD Start --> Stop var className='atoc';"},"3-Chapter/2-Sequence diagram.html":{"url":"3-Chapter/2-Sequence diagram.html","title":"第三章 第2节：Sequence diagram","keywords":"","body":"第三章 第2节：Sequence diagram sequenceDiagram Alice->>John: Hello John, how are you? John-->>Alice: Great! sequenceDiagram Alice->>John: Hello John, how are you? John-->>Alice: Great! sequenceDiagram Alice->>John: Hello John, how are you? John-->>Alice: Great! var className='atoc';"},"3-Chapter/3-Class Diagram.html":{"url":"3-Chapter/3-Class Diagram.html","title":"第三章 第3节：Class Diagram","keywords":"","body":"第三章 第3节：Class Diagram 暂时不支持 classDiagram class BankAccount BankAccount : +String owner BankAccount : +Bigdecimal balance BankAccount : +deposit(amount) BankAccount : +withdrawl(amount) classDiagram class BankAccount BankAccount : +String owner BankAccount : +Bigdecimal balance BankAccount : +deposit(amount) BankAccount : +withdrawl(amount) classDiagram class BankAccount BankAccount : +String owner BankAccount : +Bigdecimal balance BankAccount : +deposit(amount) BankAccount : +withdrawl(amount) var className='atoc';"},"3-Chapter/4-State Diagram.html":{"url":"3-Chapter/4-State Diagram.html","title":"第三章 第4节：State Diagram","keywords":"","body":"第三章 第4节：State Diagram stateDiagram [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] stateDiagram [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] stateDiagram [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] var className='atoc';"},"3-Chapter/5-Entity Relationship Diagram.html":{"url":"3-Chapter/5-Entity Relationship Diagram.html","title":"第三章 第5节：Entity Relationship Diagram","keywords":"","body":"第三章 第5节：Entity Relationship Diagram erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses var className='atoc';"},"3-Chapter/6-User Journey.html":{"url":"3-Chapter/6-User Journey.html","title":"第三章 第6节：User Journey","keywords":"","body":"第三章 第6：User Journey 暂时不支持 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me var className='atoc';"},"3-Chapter/7-Gantt.html":{"url":"3-Chapter/7-Gantt.html","title":"第三章 第7节：Gantt","keywords":"","body":"第三章 第7节：Gantt gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d var className='atoc';"},"3-Chapter/8-Pie Chart.html":{"url":"3-Chapter/8-Pie Chart.html","title":"第三章 第8节：Pie Chart","keywords":"","body":"第三章 第8节：Pie Chart pie title Pets adopted by volunteers \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 pie title Pets adopted by volunteers \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 pie title Pets adopted by volunteers \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 var className='atoc';"},"3-Chapter/9-gitGraph.html":{"url":"3-Chapter/9-gitGraph.html","title":"第三章 第9节：gitGraph","keywords":"","body":"第三章 第9节：gitGraph gitGraph: options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch gitGraph: options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch gitGraph: options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch var className='atoc';"},"3-Chapter/10-安装 mermaid live editor.html":{"url":"3-Chapter/10-安装 mermaid live editor.html","title":"第三章 第10节：安装 mermaid live editor","keywords":"","body":"第三章 第10节：安装 mermaid live editor 制作并运行 mermaid live editor镜像 cd ~/src/ sudo apt install docker.io sudo service docker start sudo docker build -t mermaidjs/mermaid-live-editor https://github.com/mermaidjs/mermaid-live-editor.git sudo docker run -d -p 8000:8000 mermaidjs/mermaid-live-editor 打开 mermaid live editor: http://localhost:8000 docker镜像的导出与导入 如果服务器网路不好或者pull不下来镜像，只能在其它网路比较好的机器上pull下来镜像，导出成一个文件，再复制到网路不好的机器上，然后再从文件中导入进来，这样在网络不好的机器上也能使用docker镜像了。 使用 sudo docker images 查看本机所有的镜像文件 sudo docker save 80ea13983ed6> ./mermaid-live-editor_80ea13983ed6.tar 将镜像保存为本地文件，其中80ea13983ed6为image id 将保存到本地的文件上传到不能pull的服务器上，网络相通的情况下可以直接使用scp命令 使用load方法加载刚才上传的tar文件 sudo docker load 在新的机器上再此使用sudo docker images命令查看本机的镜像，检查刚才load的镜像有没有加载进来，发现加载进来的镜像名称、标签均为none，使用sudo docker tag 80ea13983ed6 mermaidjs/mermaid-live-editor:latest 修改为原来的镜像名称和标签名称，其中80ea13983ed6 为images id 使用sudo docker run -d -p 8000:8000 mermaidjs/mermaid-live-editor 加载镜像，验证镜像是否能够成功的“run” Mermaid在线编辑器 https://mermaid-js.github.io/mermaid-live-editor/#/edit/ var className='atoc';"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"Git 分散式版本控制软件 Markdown Aaron Swartz 跟John Gruber共同设计的排版语言 LaTeX var className='atoc';"}}